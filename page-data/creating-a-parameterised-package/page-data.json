{"componentChunkName":"component---src-pages-creating-a-parameterised-package-mdx","path":"/creating-a-parameterised-package/","result":{"pageContext":{"frontmatter":{"title":"Creating Parameterised Experiment Packages"},"relativePagePath":"/creating-a-parameterised-package.mdx","titleType":"page","MdxNode":{"id":"3c26180a-8288-59d3-b148-1d609a6d6c4d","children":[],"parent":"5e8a7631-9ac6-590c-8a73-0449a853165a","internal":{"content":"---\ntitle: Creating Parameterised Experiment Packages\n---\n\n<!--\n\n  Copyright IBM Inc. All Rights Reserved.\n  SPDX-License-Identifier: Apache-2.0\n\n-->\n\n<PageDescription>\n\nUse this page to learn what parameterised packages are and how to create them.\n\n</PageDescription>\n\n<AnchorLinks>\n  <AnchorLink>What is a parameterised virtual experiment package?</AnchorLink>\n  <AnchorLink>Structure of a parameterised virtual experiment package</AnchorLink>\n  <AnchorLink>The Base section</AnchorLink>\n  <AnchorLink>The Parameterisation section</AnchorLink>\n  <AnchorLink>The Metadata section</AnchorLink>\n  <AnchorLink>Adding a parameterised package to a registry</AnchorLink>\n  <AnchorLink>Example</AnchorLink>\n</AnchorLinks>\n\nA `parameterised virtual experiment`defines how to run a virtual experiment in a particular way.\n\nST4SD provides a registry for parameterised virtual experiments.\nThe registry allows researchers to browse and use these packages.\nEach ST4SD deployment has a registry and we also maintain [a publicly available registry](https://registry.st4sd.res.ibm.com/).\n\nThis document explains how developers can write  parameterised virtual experiment package.\nFor how these packages can be used by others see [using the virtual experiment registry](/using-the-virtual-experiments-registry-ui).\n\n\n\n## What is a parameterised virtual experiment package?\n\nA parameterised virtual experiment package is a python dictionary (or YAML or JSON structure) that describes:\n\n- How to access a virtual experiment\n- What options to allow users to change\n- What options have preset values\n- Metadata about the package.\n\nIt is **parameterised** as the package can set the values of options in the base experiment to give certain behaviours e.g. setting a quantum method known to be fast, that can't be overridden by the user.\nThe package can also specify a restricted set of values for an option.\nIn this way the same base virtual experiment can be configured in many ways and provide different parameterised packages for different tasks.\n\n\n\n## Structure of a parameterised virtual experiment package\n\nA parameterised package has three main sections:\n\n1. The base packages (i.e. workflow definitions) that the virtual experiment consists of.\n   - Where they are located, what version to get, and how to get them. Often there will be just one.\n2. The parameterisation information:\n   - Presets: options that  users cannot change.\n   - Execution options: options that users can change potential with some restrictions.\n3. Metadata:\n   - Various other information about the package e.g. description, license, maintainer and keywords.\n\nEach of these is a top-level key in the package description.\nThe following snippet shows this top-level structure:\n\n```python\ndefinition = {\n    \"base\": {\n        # Required: Base package information ...\n    }\n    \"metadata\": {\n    \t\t# Required: Various info about the package  ...\n    },\n    \"parameterisation\": {\n      # Optional: What values are set and what can be changed ..\n    }\n}\n```\n\n\n\nThe rest of this document explains each section, outlining what information is required and optional.\n\n<InlineNotification>\n\nIn the following we use YAML to describe the section structure, for ease of explanation. This would have to be converted to a python dictionary to upload to the registry. An example of doing this is given in the [pushing a package](#pushing-the-package) section.\n\n</InlineNotification>\n\n## The Base section\n\n<AnchorLinks small>\n  <AnchorLink>Sources</AnchorLink>\n  <AnchorLink>Specifying image registry dependencies</AnchorLink>\n</AnchorLinks>\n\nThe `base` section describes where the base virtual experiment is and how to access it.\n\n```yaml\nbase:\n  packages:\n  - $PACKAGE_DEFINITION\n```\n\nA virtual experiment can contain multiple base packages although for handwritten packages this will usually be one.\n\n```yaml\npackages:\n- name: # OPTIONAL - defaults to \"main\", is required\n        # for multi-package experiments\n  source:\n     #REQUIRED: ONE package source type. See below for options\n     $PACKAGE_SOURCETYPE: $PACKAGE_SOURCE_STRUCTURE\n  config:\n    # How to read the experiment from the given source e.g. manifest etc.\n    # config is REQUIRED IF the base virtual experiment uses standard\n    # packaging (is a workflow conf + manifest)\n    path: # relative (to the \"root\" of `${BASE_PACKAGE}.source`)\n          # path to the virtual experiment (flowir) configuration file\n    manifestPath: # path to the virtual experiments manifest file\n                  # relative to \"root\" of `${BASE_PACKAGE}.source`\n  dependencies:\n    imageRegistries:\n      #OPTIONAL: list of image registry structures defining how to access\n      # the images required by the experiment. See below for options.\n      - $IMAGE_REGISTRY_STRUCTURE\n```\n\n### Sources\n\nSelect the source that matches where your virtual experiment is stored\n\n#### Git source\n\n\n\n```Yaml\ngit:\n  location:\n    url: the http url of the repo\n    # Must specify exactly ONE of branch, tag, and commit\n    branch: name of branch\n    tag: name of tag\n    commit: git commit hash\n  security:\n    oauth:\n      # You must use exactly ONE of `value` or `valueFrom`.\n      # \"value\" if automatically converted to \"valueFrom.secretKeyRef` when you push the package\n      valueFrom:\n        secretKeyRef:\n          name: name of secret containing oauthSecret key\n          key: name of key holding the token, defaults to \"oauth-token\"\n      value: an oauth api key for authenticating to git with HTTPS basic auth\n```\n\n<InlineNotification kind=\"info\">\n\nST4SD will use the oauth-token you provide to `git clone https://${oauth-token}@server.com/your-org/your-repo.git`.\n\nIf you are using [Github](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic) to host your git repository you can generate a Personal Access Token with just read-access to your git repository.\n\nIf you are using [Gitlab](https://docs.gitlab.com/ee/user/project/deploy_tokens/#create-a-deploy-token), you can generate a Deploy Token with read acces to your project.\n\n</InlineNotification>\n\n<InlineNotification kind=\"warning\">\n\nFor [Github](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#using-a-personal-access-token-on-the-command-line) and [Gitlab](https://docs.gitlab.com/ee/user/project/deploy_tokens/#clone-a-repository) you should prefix the Personal Access Token with your username like so: `${Username}:${PersonalAccessToken}`.\n\n</InlineNotification>\n\n#### Datashim source\n\n\n\nIf you have installed [Datashim](https://github.com/datashim-io/datashim) on your cluster, you can use a Datashim `dataset` as the location of your virtual experiment base package.\n\n```yaml\ndataset:\n  # No need for a security field because Datashim removes this requirement.\n  location:\n    dataset: the name of the dataset object\n```\n\n\n\n\n#### S3 source\n\n\n\n```yaml\ns3:\n  location:\n    region: region (optional)\n    endpoint: S3 endpoint url\n    bucket: bucket name\n  security:\n    valueFrom:\n        # Must choose exactly ONE of secretS3KeyRef and valuseS3\n        # \"valuesS3\" is automatically converted to \"secretS3KeyRef\" when you push the package\n      secretS3KeyRef:\n        name: name of existing kubernetes Secret object containing access information\n          # keyAccessKeyId has default value \"accessKeyId\"\n        keyAccessKeyId: key in Secret object that holds accessKeyId\n          # secretAccessKey has default value \"secretAccessKey\"\n        keySecretAccessKey: key in Secret object that holds secretAccessKey\n      s3Ref:\n        accessKeyId: Value of accessKeyId\n        secretAccessKey: Value of accessKeyId\n```\n\n\n\n\n### Specifying image registry dependencies\n\nVirtual experiments often use images which may be stored in private registries. This structure allows the developer to provide ST4SD with information on how to access these registries.\n\n```yaml\ndependencies:\n  #An Optional dictionary of dependency types\n  imageRegistries: # An optional list of image registries struct\n  - serverUrl: the url to the image registry\n    security:\n      valueFrom:\n        # Must select exactly 1 of secretKeyRef and usernamePassword\n        # \"usernamePassword\" is automatically converted to a \"secretKeyRef\" when the package is pushed\n        secretKeyRef:\n          name: name of an existing \"docker-registry\" kubernetes secret object containing the access information\n          key: Name of key containing the auth information (default is .dockerconfigjson)\n        usernamePassword:\n          # here expect fields we would use for `kubectl create secret docker-registry`\n          username: ...\n          password: ...\n\n```\n\n## The Parameterisation section\n\n<AnchorLinks small>\n  <AnchorLink>Parameterisation rules</AnchorLink>\n  <AnchorLink>Presets</AnchorLink>\n  <AnchorLink>Execution options</AnchorLink>\n</AnchorLinks>\n\nST4SD supports 2 levels of parameterisation:`presets` which are options that virtual experiment developers decide and users cannot change; and `executionOptions`  that virtual experiment developers allow users to override potentially with some limit.\n\n```yaml\nparameterisation:\n  presets: ...\n  executionOptions: ...\n```\n\n### Parameterisation rules\n\nThe parameter types that can be specified in each section are:\n\n- variables (`variables`): Values for variables used in the experiment\n- data-files (`data`) : Values for data files used by the experiment\n- platform (`platform`): Value for the platform (named set of variables) to use\n- runtime arguments (`runtime`) : `elaunch.py` command line arguments\n\nBoth `presets` and `executionOptions` can be specified in same package.\n\nIt is an error to specify the same parameter (variable, data file, runtime option) in both sections. In addition `platform` can only be specified in one of the two sections.\n\nIf a virtual experiment has a parameter that is not specified in either section it is `preset` with its default value and cannot be changed.\n\n<InlineNotification kind=\"warning\">\n\nIf a developer wants a user to be able to provide a value for a parameter they **must** specify it in `executionOptions`\n\n</InlineNotification>\n\nFor `executionOptions` the value of the `parameter` is resolved as follows:\n\n1. The value provided by the user\n2. The default value provided by the developer in the parameterised package if there is one\n3. The first value in the array of options provided by the developer in the parameterised package if there is one\n4. If none of the above exist the default value of the parameter in the `base-package` is used\n\n### Presets\n\nUse presets to define set values for parameters\n\n\n```yaml\nparameterisation:\n  presets:  # optional\n    # Fields defined here *cannot* be overridden by `executionOptions`.\n    # All fields are optional\n    variables: #A list of preset values for variables in the virtual experiment\n    - name: $name of variable\n      value: $variableValue\n    data:\n      - name: name of a file in the \"data\" directory\n        value: contents of file - utf8 string (not suitable for binary files)\n    runtime:\n      args:\n      - array of `elaunch.py` command line strings\n    platform:  #Value for the experiment platform.\n\n\n\n```\n\n\n\n### Execution options\n\nUse execution options to allow user to choose values for parameters if they want\n\n```yaml\n  executionOptions: # optional\n    # users may override values within constraints that workflow developers set\n    variables:\n    # Variables that the developer allows the user to override.\n    # These CANNOT appear in presets.variables\n    - name: $variable name\n      # .value and .valueFrom are both optional and mutually exclusive\n      # if neither fields exist then users can set variable to any value.\n      #   at start, if users do not provide a value, the variable receives the\n      #   default value that the selected platform defines for this variable\n      value: an optional default value that users can override\n      valueFrom: # An optional array of available choices (1st is default)\n      - value: value of variable (a choice, 1st choice is also the default)\n    data: #A list of data files whose contents the user can set.\n    - name: filename under `data` directory, the file must already exist\n    runtime: # Arguments to pass to `elaunch.py`\n             # (cannot include -i -a -d --instanceName)\n      args:\n      - array of elaunch.py command line strings\n    platform: # Choices for platform selection.\n              # Cannot be specified here if in `presets`\n    - an array of platform names. # If the user does not specifying one on start\n                                  # then the 1st entry is used. If no platform\n                                  # is specified the `default` platform is used\n\n\n```\n\n\n## The Metadata section\n\nThe `metadata` section is used to provide various other information about the parameterised virtual experiment.\n\n\n```yaml\nmetadata:\n  package: #All the maintainer metadata. Can decide exact structure at implementation time.\n    name: the package name\n    tags: # Optional\n    - latest # On Push, auto insert latest if missing\n    maintainer: email (optional)\n    license: some string (optional)\n    keywords: # optional\n    - keyword 1\n    - keyword 2\n\n```\n\n\n\n## Adding a parameterised package to a registry\n\n<AnchorLinks small>\n  <AnchorLink>Pushing the package</AnchorLink>\n  <AnchorLink>Parameterised Package Identifier</AnchorLink>\n  <AnchorLink>Package Tags</AnchorLink>\n  <AnchorLink>Registry metadata</AnchorLink>\n</AnchorLinks>\n\n### Pushing the package\n\n#### From a python dictionary\n\nThe parameterised package is stored as a dictionary in a python module `mypackage.py` (can be any name). The dictionary is assigned to a variable (can be any name) e.g.\n\n```python\nd = {\n  \"base\": ...\n}\n```\n\nThen\n\n```python\nimport mypackage\napi.api_experiment_push(mypackage.d)\n```\n\n\n\n#### From YAML\n\nThe parameterised package is stored as YAML in a  file `mypackage.yaml` (can be any name).\n\n```python\nimport yaml\nwith open('mypackage.yaml') as f:\n\tapi.api_experiment_push(yaml.load(f))\n```\n\n\n\n#### From JSON\n\nThe parameterised package is stored as  JSON in a file `mypackage.json` (can be any name).\n\n```python\nimport json\nwith open('mypackage.json') as f:\n\tapi.api_experiment_push(json.load(f))\n```\n\n\n\n#### Registry actions when a package is pushed\n\nOn pushing a parameterised virtual experiment package, the registry:\n\n* Generates a unique Id for the entry  see [Parameterised Packaged Identifier](#parameterised-package-identifier)\n* Applies and updates tags - see [Package Tags](#package-tags)\n* Stores any credentials as Kubernetes secrets and converts the relevant fields in the parameterised package to `secretKeyRef` and `secretS3KeyRef` types.\n* Adds additional data to the parameterised package - see [registry metadata](#registry-metadata)\n\n\n### Parameterised Package Identifier\n\nWhen  a parameterised package is pushed to the virtual experiment registry it is assigned a  `digest` which is unique between all packages with the same package name (the value of `metadata.package.name`).\n\nThe unique identifier of the package is then `$packageName@$digest`. For example ``my-experiment@sha256x16092ca4bb13955b1397bf38cfba45ef11c9933bf796454a81de4f86``\n\nBy convention the registry assumes  parameterised packages with the same package name represent different versions of that package. These are collected together in the registry-ui with the details of the most recent (last uploaded) package shown and links to all previous versions of the package\n\n### Package Tags\n\nParameterized packages can have  *tags*  applied to them. A tag is a shorthand for referencing the package. For example by adding the tag `1.0` to the package `my-experiment@sha256x16092ca4bb13955b1397bf38cfba45ef11c9933bf796454a81de4f86` you can reference it as `my-experiment:1.0` in various operations.\n\nDevelopers can specify tags when pushing a package using the  `metadata.package.tags` field of the package payload. Tagging a parameterised package with a tag removes the tag from any other parameterised package with the same name. This guarantees that if `$packageName:$tag` exists, it points to exactly one `$packageName@$digest`. The API call `api_experiment_update_tags(packageIdentifier, tags)` can also be used add or remove a tag to a package at any time. Note, this call requires `tags` to include **all** tags you want associated with the package. If an existing tag is not in this list then it will be removed.\n\nThe current tags associated with a package can be found by inspecting the `metadata.package.tags` element of the package definition in the registry.\n\n<InlineNotification>\n\nWhen a package is pushed it is automatically tagged `latest` by the registry.\nIf only a package-name is passed to an API call require a package identifier then the tag `latest` is assumed.\n\n</InlineNotification>\n\n<InlineNotification kind=\"warning\">\n\n`latest` can be moved to another digest with the same-package name if desired using `api_experiment_update_tags`. However `latest` cannot be removed. That is you will receive an error if you omit it from the `tag` list in `api_experiment_update_tags` for a digest that is tagged with `:latest`. You can only remove the `:latest` tag from a digest if you tag a different digest with the same name `package-name` with the tag  `:latest`.\n\n</InlineNotification>\n\n\n#### Example\n\nA parameterised package with name `my-experiment` is pushed to the registry. It is given the digest `sha256x16092ca4bb13955b1397bf38cfba45ef11c9933bf796454a81de4f86`.\n\nAll 3 identifiers below point to the same digest:\n\n- `my-experiment`\n- `my-experiment:latest`\n- `my-experiment@sha256x16092ca4bb13955b1397bf38cfba45ef11c9933bf796454a81de4f8`\n\nAny of these 3 identifiers can be used to refer to the new parameterised package in API call e.g. to start an instance of this parameterised virtual experiment all the following will work:\n\n```python\napi.api_experiment_start(\"my-experiment\", payload={})\napi.api_experiment_start(\"my-experiment:latest\", payload={})\napi.api_experiment_start(\"my-experiment@sha256x16092ca4bb13955b1397bf38cfba45ef11c9933bf796454a81de4f86\", payload={})\n```\n\n\n\n#### Package tag update rules\n\nIf a tag is requested for a digest and that tag is already associated with another digest with the same package-name,  then the registry updates `$packageName:$tag` to point to the new package. This ensures that `$packageName:$tag` points to a unique digest even if the workflow developers pushed the `$tag` in the past.\n\nIn general this operation involves updating the `metadata.registry.tags` fields of all parameterised packages with the same `package-name`.\n\n### Registry metadata\n\nThe registry adds various information it discovers to the `metadata` section of the package under the `registry` key. This includes the id of the package\n\n```yaml\nregistry: #All data added by runtime - developers cannot set anything under registry\n    digest: $a string up to 63 characters #The identifier\n    createdOn: UTC time that this digest was created, format is %Y-%m-%dT%H%M%S.%f%z\n    timesExecuted: int - automatically increased every time a user launches this virtual experiment entry in the ST4SD deployment the registry is attached to\n    tags: #A list of tags which point to this digest.\n    - $TAG # This is a SUBSET of metadata.package.tags. It can be EMPTY if no tag points to this digest anymore\n    interface: {} # ST4SD injects the Virtual experiment interface if it exists\n    data: #The list of filenames under the `data` directory (just top-level files, NO directories)\n    - name: $DATA_FILE_NAME\n    inputs: #The list of files under the `input` directory. These are files that users must provide when launching this virtual experiment\n    - name: $INPUT_FILE_NAME\n    containerImages: #A list of the names of the container images that could be used by this virtual experiment. If\n    - name: the name of a container image (e.g. a URL)\n```\n\n\n\n## Example\n\n\nHere is an example parameterised package for the [sum-numbers toy virtual experiment](/tutorial) which lives on `git` that demonstrates many of the features discussed above.\n\n\n```python\ndefinition = {\n    \"base\": {\n        # We define the one or more base-packages (here just one)\n        \"packages\": [{\n            \"source\": {\n                \"git\": {\n                    \"location\": {\n                        # This one lives on Git, under the \"main\" branch, we can also use\n                        # \"tag\" and \"commit\"\n                        \"url\": \"https://github.com/st4sd/sum-numbers.git\",\n                        \"branch\": \"main\"\n                    }\n                }\n            },\n            \"config\": {  # Optional - not required for this example\n                \"path\": \".\", # use when package is not at the root of the source location\n                \"manifestPath\": None,  # relative path to manifest YAML (not used in this example)\n            }\n        }]\n    },\n    \"metadata\": {\n        \"package\": {\n            \"name\": \"sum-numbers\", # Required\n            \"tags\": [\"latest\"],  # Optional - *always* includes \"latest\"\n            \"maintainer\": \"vassilis.vassiliadis@ibm.com\", # Optional but recommended\n            \"description\": \"Toy virtual experiment\", # Optional but recommended\n            \"keywords\": [ # Optional but recommended\n                \"openshift\", \"hello-world\"\n            ]\n        }\n    },\n    \"parameterisation\": {  # Optional but recommended\n        \"presets\": {  # Options that users CANNOT override\n            \"runtime\": {\n                \"args\": [\n                    # *Always* register the workflow to the ST4SD datastore (aka Centralized Database)\n                    \"--registerWorkflow=yes\"\n                ]\n            }\n        },\n        \"executionOptions\": { # Options that users *MAY* override and *MUST* adhere to rules below\n            \"variables\": [\n                # Configures the number of replicas, can be any positive integer, or 1 if unspecified\n                {\"name\": \"numberOfPoints\", \"value\": \"1\"}\n            ],\n            \"data\": [\n                # Users *may* provide a `cat_me.txt` file\n                {\"name\": \"cat_me.txt\"}\n            ],\n            # Users can *only* execute the `openshift` and `default` platforms - even if the virtual experiment\n            # comes with more platform definitions\n            \"platform\": [\"openshift\", \"default\"]\n        }\n    }\n}\n\napi.api_experiment_push(definition)\n```\n","type":"Mdx","contentDigest":"da51579a0f4b2ff0bf9397e2c678377d","owner":"gatsby-plugin-mdx","counter":192},"frontmatter":{"title":"Creating Parameterised Experiment Packages"},"exports":{},"rawBody":"---\ntitle: Creating Parameterised Experiment Packages\n---\n\n<!--\n\n  Copyright IBM Inc. All Rights Reserved.\n  SPDX-License-Identifier: Apache-2.0\n\n-->\n\n<PageDescription>\n\nUse this page to learn what parameterised packages are and how to create them.\n\n</PageDescription>\n\n<AnchorLinks>\n  <AnchorLink>What is a parameterised virtual experiment package?</AnchorLink>\n  <AnchorLink>Structure of a parameterised virtual experiment package</AnchorLink>\n  <AnchorLink>The Base section</AnchorLink>\n  <AnchorLink>The Parameterisation section</AnchorLink>\n  <AnchorLink>The Metadata section</AnchorLink>\n  <AnchorLink>Adding a parameterised package to a registry</AnchorLink>\n  <AnchorLink>Example</AnchorLink>\n</AnchorLinks>\n\nA `parameterised virtual experiment`defines how to run a virtual experiment in a particular way.\n\nST4SD provides a registry for parameterised virtual experiments.\nThe registry allows researchers to browse and use these packages.\nEach ST4SD deployment has a registry and we also maintain [a publicly available registry](https://registry.st4sd.res.ibm.com/).\n\nThis document explains how developers can write  parameterised virtual experiment package.\nFor how these packages can be used by others see [using the virtual experiment registry](/using-the-virtual-experiments-registry-ui).\n\n\n\n## What is a parameterised virtual experiment package?\n\nA parameterised virtual experiment package is a python dictionary (or YAML or JSON structure) that describes:\n\n- How to access a virtual experiment\n- What options to allow users to change\n- What options have preset values\n- Metadata about the package.\n\nIt is **parameterised** as the package can set the values of options in the base experiment to give certain behaviours e.g. setting a quantum method known to be fast, that can't be overridden by the user.\nThe package can also specify a restricted set of values for an option.\nIn this way the same base virtual experiment can be configured in many ways and provide different parameterised packages for different tasks.\n\n\n\n## Structure of a parameterised virtual experiment package\n\nA parameterised package has three main sections:\n\n1. The base packages (i.e. workflow definitions) that the virtual experiment consists of.\n   - Where they are located, what version to get, and how to get them. Often there will be just one.\n2. The parameterisation information:\n   - Presets: options that  users cannot change.\n   - Execution options: options that users can change potential with some restrictions.\n3. Metadata:\n   - Various other information about the package e.g. description, license, maintainer and keywords.\n\nEach of these is a top-level key in the package description.\nThe following snippet shows this top-level structure:\n\n```python\ndefinition = {\n    \"base\": {\n        # Required: Base package information ...\n    }\n    \"metadata\": {\n    \t\t# Required: Various info about the package  ...\n    },\n    \"parameterisation\": {\n      # Optional: What values are set and what can be changed ..\n    }\n}\n```\n\n\n\nThe rest of this document explains each section, outlining what information is required and optional.\n\n<InlineNotification>\n\nIn the following we use YAML to describe the section structure, for ease of explanation. This would have to be converted to a python dictionary to upload to the registry. An example of doing this is given in the [pushing a package](#pushing-the-package) section.\n\n</InlineNotification>\n\n## The Base section\n\n<AnchorLinks small>\n  <AnchorLink>Sources</AnchorLink>\n  <AnchorLink>Specifying image registry dependencies</AnchorLink>\n</AnchorLinks>\n\nThe `base` section describes where the base virtual experiment is and how to access it.\n\n```yaml\nbase:\n  packages:\n  - $PACKAGE_DEFINITION\n```\n\nA virtual experiment can contain multiple base packages although for handwritten packages this will usually be one.\n\n```yaml\npackages:\n- name: # OPTIONAL - defaults to \"main\", is required\n        # for multi-package experiments\n  source:\n     #REQUIRED: ONE package source type. See below for options\n     $PACKAGE_SOURCETYPE: $PACKAGE_SOURCE_STRUCTURE\n  config:\n    # How to read the experiment from the given source e.g. manifest etc.\n    # config is REQUIRED IF the base virtual experiment uses standard\n    # packaging (is a workflow conf + manifest)\n    path: # relative (to the \"root\" of `${BASE_PACKAGE}.source`)\n          # path to the virtual experiment (flowir) configuration file\n    manifestPath: # path to the virtual experiments manifest file\n                  # relative to \"root\" of `${BASE_PACKAGE}.source`\n  dependencies:\n    imageRegistries:\n      #OPTIONAL: list of image registry structures defining how to access\n      # the images required by the experiment. See below for options.\n      - $IMAGE_REGISTRY_STRUCTURE\n```\n\n### Sources\n\nSelect the source that matches where your virtual experiment is stored\n\n#### Git source\n\n\n\n```Yaml\ngit:\n  location:\n    url: the http url of the repo\n    # Must specify exactly ONE of branch, tag, and commit\n    branch: name of branch\n    tag: name of tag\n    commit: git commit hash\n  security:\n    oauth:\n      # You must use exactly ONE of `value` or `valueFrom`.\n      # \"value\" if automatically converted to \"valueFrom.secretKeyRef` when you push the package\n      valueFrom:\n        secretKeyRef:\n          name: name of secret containing oauthSecret key\n          key: name of key holding the token, defaults to \"oauth-token\"\n      value: an oauth api key for authenticating to git with HTTPS basic auth\n```\n\n<InlineNotification kind=\"info\">\n\nST4SD will use the oauth-token you provide to `git clone https://${oauth-token}@server.com/your-org/your-repo.git`.\n\nIf you are using [Github](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic) to host your git repository you can generate a Personal Access Token with just read-access to your git repository.\n\nIf you are using [Gitlab](https://docs.gitlab.com/ee/user/project/deploy_tokens/#create-a-deploy-token), you can generate a Deploy Token with read acces to your project.\n\n</InlineNotification>\n\n<InlineNotification kind=\"warning\">\n\nFor [Github](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#using-a-personal-access-token-on-the-command-line) and [Gitlab](https://docs.gitlab.com/ee/user/project/deploy_tokens/#clone-a-repository) you should prefix the Personal Access Token with your username like so: `${Username}:${PersonalAccessToken}`.\n\n</InlineNotification>\n\n#### Datashim source\n\n\n\nIf you have installed [Datashim](https://github.com/datashim-io/datashim) on your cluster, you can use a Datashim `dataset` as the location of your virtual experiment base package.\n\n```yaml\ndataset:\n  # No need for a security field because Datashim removes this requirement.\n  location:\n    dataset: the name of the dataset object\n```\n\n\n\n\n#### S3 source\n\n\n\n```yaml\ns3:\n  location:\n    region: region (optional)\n    endpoint: S3 endpoint url\n    bucket: bucket name\n  security:\n    valueFrom:\n        # Must choose exactly ONE of secretS3KeyRef and valuseS3\n        # \"valuesS3\" is automatically converted to \"secretS3KeyRef\" when you push the package\n      secretS3KeyRef:\n        name: name of existing kubernetes Secret object containing access information\n          # keyAccessKeyId has default value \"accessKeyId\"\n        keyAccessKeyId: key in Secret object that holds accessKeyId\n          # secretAccessKey has default value \"secretAccessKey\"\n        keySecretAccessKey: key in Secret object that holds secretAccessKey\n      s3Ref:\n        accessKeyId: Value of accessKeyId\n        secretAccessKey: Value of accessKeyId\n```\n\n\n\n\n### Specifying image registry dependencies\n\nVirtual experiments often use images which may be stored in private registries. This structure allows the developer to provide ST4SD with information on how to access these registries.\n\n```yaml\ndependencies:\n  #An Optional dictionary of dependency types\n  imageRegistries: # An optional list of image registries struct\n  - serverUrl: the url to the image registry\n    security:\n      valueFrom:\n        # Must select exactly 1 of secretKeyRef and usernamePassword\n        # \"usernamePassword\" is automatically converted to a \"secretKeyRef\" when the package is pushed\n        secretKeyRef:\n          name: name of an existing \"docker-registry\" kubernetes secret object containing the access information\n          key: Name of key containing the auth information (default is .dockerconfigjson)\n        usernamePassword:\n          # here expect fields we would use for `kubectl create secret docker-registry`\n          username: ...\n          password: ...\n\n```\n\n## The Parameterisation section\n\n<AnchorLinks small>\n  <AnchorLink>Parameterisation rules</AnchorLink>\n  <AnchorLink>Presets</AnchorLink>\n  <AnchorLink>Execution options</AnchorLink>\n</AnchorLinks>\n\nST4SD supports 2 levels of parameterisation:`presets` which are options that virtual experiment developers decide and users cannot change; and `executionOptions`  that virtual experiment developers allow users to override potentially with some limit.\n\n```yaml\nparameterisation:\n  presets: ...\n  executionOptions: ...\n```\n\n### Parameterisation rules\n\nThe parameter types that can be specified in each section are:\n\n- variables (`variables`): Values for variables used in the experiment\n- data-files (`data`) : Values for data files used by the experiment\n- platform (`platform`): Value for the platform (named set of variables) to use\n- runtime arguments (`runtime`) : `elaunch.py` command line arguments\n\nBoth `presets` and `executionOptions` can be specified in same package.\n\nIt is an error to specify the same parameter (variable, data file, runtime option) in both sections. In addition `platform` can only be specified in one of the two sections.\n\nIf a virtual experiment has a parameter that is not specified in either section it is `preset` with its default value and cannot be changed.\n\n<InlineNotification kind=\"warning\">\n\nIf a developer wants a user to be able to provide a value for a parameter they **must** specify it in `executionOptions`\n\n</InlineNotification>\n\nFor `executionOptions` the value of the `parameter` is resolved as follows:\n\n1. The value provided by the user\n2. The default value provided by the developer in the parameterised package if there is one\n3. The first value in the array of options provided by the developer in the parameterised package if there is one\n4. If none of the above exist the default value of the parameter in the `base-package` is used\n\n### Presets\n\nUse presets to define set values for parameters\n\n\n```yaml\nparameterisation:\n  presets:  # optional\n    # Fields defined here *cannot* be overridden by `executionOptions`.\n    # All fields are optional\n    variables: #A list of preset values for variables in the virtual experiment\n    - name: $name of variable\n      value: $variableValue\n    data:\n      - name: name of a file in the \"data\" directory\n        value: contents of file - utf8 string (not suitable for binary files)\n    runtime:\n      args:\n      - array of `elaunch.py` command line strings\n    platform:  #Value for the experiment platform.\n\n\n\n```\n\n\n\n### Execution options\n\nUse execution options to allow user to choose values for parameters if they want\n\n```yaml\n  executionOptions: # optional\n    # users may override values within constraints that workflow developers set\n    variables:\n    # Variables that the developer allows the user to override.\n    # These CANNOT appear in presets.variables\n    - name: $variable name\n      # .value and .valueFrom are both optional and mutually exclusive\n      # if neither fields exist then users can set variable to any value.\n      #   at start, if users do not provide a value, the variable receives the\n      #   default value that the selected platform defines for this variable\n      value: an optional default value that users can override\n      valueFrom: # An optional array of available choices (1st is default)\n      - value: value of variable (a choice, 1st choice is also the default)\n    data: #A list of data files whose contents the user can set.\n    - name: filename under `data` directory, the file must already exist\n    runtime: # Arguments to pass to `elaunch.py`\n             # (cannot include -i -a -d --instanceName)\n      args:\n      - array of elaunch.py command line strings\n    platform: # Choices for platform selection.\n              # Cannot be specified here if in `presets`\n    - an array of platform names. # If the user does not specifying one on start\n                                  # then the 1st entry is used. If no platform\n                                  # is specified the `default` platform is used\n\n\n```\n\n\n## The Metadata section\n\nThe `metadata` section is used to provide various other information about the parameterised virtual experiment.\n\n\n```yaml\nmetadata:\n  package: #All the maintainer metadata. Can decide exact structure at implementation time.\n    name: the package name\n    tags: # Optional\n    - latest # On Push, auto insert latest if missing\n    maintainer: email (optional)\n    license: some string (optional)\n    keywords: # optional\n    - keyword 1\n    - keyword 2\n\n```\n\n\n\n## Adding a parameterised package to a registry\n\n<AnchorLinks small>\n  <AnchorLink>Pushing the package</AnchorLink>\n  <AnchorLink>Parameterised Package Identifier</AnchorLink>\n  <AnchorLink>Package Tags</AnchorLink>\n  <AnchorLink>Registry metadata</AnchorLink>\n</AnchorLinks>\n\n### Pushing the package\n\n#### From a python dictionary\n\nThe parameterised package is stored as a dictionary in a python module `mypackage.py` (can be any name). The dictionary is assigned to a variable (can be any name) e.g.\n\n```python\nd = {\n  \"base\": ...\n}\n```\n\nThen\n\n```python\nimport mypackage\napi.api_experiment_push(mypackage.d)\n```\n\n\n\n#### From YAML\n\nThe parameterised package is stored as YAML in a  file `mypackage.yaml` (can be any name).\n\n```python\nimport yaml\nwith open('mypackage.yaml') as f:\n\tapi.api_experiment_push(yaml.load(f))\n```\n\n\n\n#### From JSON\n\nThe parameterised package is stored as  JSON in a file `mypackage.json` (can be any name).\n\n```python\nimport json\nwith open('mypackage.json') as f:\n\tapi.api_experiment_push(json.load(f))\n```\n\n\n\n#### Registry actions when a package is pushed\n\nOn pushing a parameterised virtual experiment package, the registry:\n\n* Generates a unique Id for the entry  see [Parameterised Packaged Identifier](#parameterised-package-identifier)\n* Applies and updates tags - see [Package Tags](#package-tags)\n* Stores any credentials as Kubernetes secrets and converts the relevant fields in the parameterised package to `secretKeyRef` and `secretS3KeyRef` types.\n* Adds additional data to the parameterised package - see [registry metadata](#registry-metadata)\n\n\n### Parameterised Package Identifier\n\nWhen  a parameterised package is pushed to the virtual experiment registry it is assigned a  `digest` which is unique between all packages with the same package name (the value of `metadata.package.name`).\n\nThe unique identifier of the package is then `$packageName@$digest`. For example ``my-experiment@sha256x16092ca4bb13955b1397bf38cfba45ef11c9933bf796454a81de4f86``\n\nBy convention the registry assumes  parameterised packages with the same package name represent different versions of that package. These are collected together in the registry-ui with the details of the most recent (last uploaded) package shown and links to all previous versions of the package\n\n### Package Tags\n\nParameterized packages can have  *tags*  applied to them. A tag is a shorthand for referencing the package. For example by adding the tag `1.0` to the package `my-experiment@sha256x16092ca4bb13955b1397bf38cfba45ef11c9933bf796454a81de4f86` you can reference it as `my-experiment:1.0` in various operations.\n\nDevelopers can specify tags when pushing a package using the  `metadata.package.tags` field of the package payload. Tagging a parameterised package with a tag removes the tag from any other parameterised package with the same name. This guarantees that if `$packageName:$tag` exists, it points to exactly one `$packageName@$digest`. The API call `api_experiment_update_tags(packageIdentifier, tags)` can also be used add or remove a tag to a package at any time. Note, this call requires `tags` to include **all** tags you want associated with the package. If an existing tag is not in this list then it will be removed.\n\nThe current tags associated with a package can be found by inspecting the `metadata.package.tags` element of the package definition in the registry.\n\n<InlineNotification>\n\nWhen a package is pushed it is automatically tagged `latest` by the registry.\nIf only a package-name is passed to an API call require a package identifier then the tag `latest` is assumed.\n\n</InlineNotification>\n\n<InlineNotification kind=\"warning\">\n\n`latest` can be moved to another digest with the same-package name if desired using `api_experiment_update_tags`. However `latest` cannot be removed. That is you will receive an error if you omit it from the `tag` list in `api_experiment_update_tags` for a digest that is tagged with `:latest`. You can only remove the `:latest` tag from a digest if you tag a different digest with the same name `package-name` with the tag  `:latest`.\n\n</InlineNotification>\n\n\n#### Example\n\nA parameterised package with name `my-experiment` is pushed to the registry. It is given the digest `sha256x16092ca4bb13955b1397bf38cfba45ef11c9933bf796454a81de4f86`.\n\nAll 3 identifiers below point to the same digest:\n\n- `my-experiment`\n- `my-experiment:latest`\n- `my-experiment@sha256x16092ca4bb13955b1397bf38cfba45ef11c9933bf796454a81de4f8`\n\nAny of these 3 identifiers can be used to refer to the new parameterised package in API call e.g. to start an instance of this parameterised virtual experiment all the following will work:\n\n```python\napi.api_experiment_start(\"my-experiment\", payload={})\napi.api_experiment_start(\"my-experiment:latest\", payload={})\napi.api_experiment_start(\"my-experiment@sha256x16092ca4bb13955b1397bf38cfba45ef11c9933bf796454a81de4f86\", payload={})\n```\n\n\n\n#### Package tag update rules\n\nIf a tag is requested for a digest and that tag is already associated with another digest with the same package-name,  then the registry updates `$packageName:$tag` to point to the new package. This ensures that `$packageName:$tag` points to a unique digest even if the workflow developers pushed the `$tag` in the past.\n\nIn general this operation involves updating the `metadata.registry.tags` fields of all parameterised packages with the same `package-name`.\n\n### Registry metadata\n\nThe registry adds various information it discovers to the `metadata` section of the package under the `registry` key. This includes the id of the package\n\n```yaml\nregistry: #All data added by runtime - developers cannot set anything under registry\n    digest: $a string up to 63 characters #The identifier\n    createdOn: UTC time that this digest was created, format is %Y-%m-%dT%H%M%S.%f%z\n    timesExecuted: int - automatically increased every time a user launches this virtual experiment entry in the ST4SD deployment the registry is attached to\n    tags: #A list of tags which point to this digest.\n    - $TAG # This is a SUBSET of metadata.package.tags. It can be EMPTY if no tag points to this digest anymore\n    interface: {} # ST4SD injects the Virtual experiment interface if it exists\n    data: #The list of filenames under the `data` directory (just top-level files, NO directories)\n    - name: $DATA_FILE_NAME\n    inputs: #The list of files under the `input` directory. These are files that users must provide when launching this virtual experiment\n    - name: $INPUT_FILE_NAME\n    containerImages: #A list of the names of the container images that could be used by this virtual experiment. If\n    - name: the name of a container image (e.g. a URL)\n```\n\n\n\n## Example\n\n\nHere is an example parameterised package for the [sum-numbers toy virtual experiment](/tutorial) which lives on `git` that demonstrates many of the features discussed above.\n\n\n```python\ndefinition = {\n    \"base\": {\n        # We define the one or more base-packages (here just one)\n        \"packages\": [{\n            \"source\": {\n                \"git\": {\n                    \"location\": {\n                        # This one lives on Git, under the \"main\" branch, we can also use\n                        # \"tag\" and \"commit\"\n                        \"url\": \"https://github.com/st4sd/sum-numbers.git\",\n                        \"branch\": \"main\"\n                    }\n                }\n            },\n            \"config\": {  # Optional - not required for this example\n                \"path\": \".\", # use when package is not at the root of the source location\n                \"manifestPath\": None,  # relative path to manifest YAML (not used in this example)\n            }\n        }]\n    },\n    \"metadata\": {\n        \"package\": {\n            \"name\": \"sum-numbers\", # Required\n            \"tags\": [\"latest\"],  # Optional - *always* includes \"latest\"\n            \"maintainer\": \"vassilis.vassiliadis@ibm.com\", # Optional but recommended\n            \"description\": \"Toy virtual experiment\", # Optional but recommended\n            \"keywords\": [ # Optional but recommended\n                \"openshift\", \"hello-world\"\n            ]\n        }\n    },\n    \"parameterisation\": {  # Optional but recommended\n        \"presets\": {  # Options that users CANNOT override\n            \"runtime\": {\n                \"args\": [\n                    # *Always* register the workflow to the ST4SD datastore (aka Centralized Database)\n                    \"--registerWorkflow=yes\"\n                ]\n            }\n        },\n        \"executionOptions\": { # Options that users *MAY* override and *MUST* adhere to rules below\n            \"variables\": [\n                # Configures the number of replicas, can be any positive integer, or 1 if unspecified\n                {\"name\": \"numberOfPoints\", \"value\": \"1\"}\n            ],\n            \"data\": [\n                # Users *may* provide a `cat_me.txt` file\n                {\"name\": \"cat_me.txt\"}\n            ],\n            # Users can *only* execute the `openshift` and `default` platforms - even if the virtual experiment\n            # comes with more platform definitions\n            \"platform\": [\"openshift\", \"default\"]\n        }\n    }\n}\n\napi.api_experiment_push(definition)\n```\n","fileAbsolutePath":"/home/travis/build/st4sd/overview/src/pages/creating-a-parameterised-package.mdx"}}},"staticQueryHashes":["1364590287","137577622","2102389209","2456312558","2746626797","3018647132","3037994772","768070550"]}