{"componentChunkName":"component---src-pages-write-advanced-experiments-mdx","path":"/write-advanced-experiments/","result":{"pageContext":{"frontmatter":{"title":"Write Advanced Experiments"},"relativePagePath":"/write-advanced-experiments.mdx","titleType":"page","MdxNode":{"id":"164ddd2f-7512-51ce-b924-aff9ef3f7b77","children":[],"parent":"65a55b36-5af4-5579-a021-beae89b01ef1","internal":{"content":"---\ntitle: Write Advanced Experiments\n---\n\nimport { CarbonForIbmDotcom } from \"@carbon/pictograms-react\";\nimport { ArtTools_01 } from \"@carbon/pictograms-react\";\n\n<!--\n\n  Copyright IBM Inc. All Rights Reserved.\n  SPDX-License-Identifier: Apache-2.0\n\n-->\n\n<PageDescription>\n\nSpend up to 60 minutes learning how to write experiments that utilize some of the advanced features of ST4SD. This page assumes you are familiar with writing basic experiments and running them locally using the elaunch.py command line tool. If you need a refresher take a moment to read our [docs](/write-experiments) before continuing any further.\n\n</PageDescription>\n\n\n<AnchorLinks>\n\n  <AnchorLink>Requirements</AnchorLink>\n  <AnchorLink>An experiment that has key-outputs</AnchorLink>\n  <AnchorLink>An experiment that has an interface</AnchorLink>\n</AnchorLinks>\n\n\n\n### Requirements\n\n- An understanding of [how to run a ST4SD workflow locally](/direct-run).\n- An understanding of [how to write a basic ST4SD workflow](/write-experiments)\n- A python 3.9+ interpreter\n- A virtual environment with the `st4sd-runtime-core` python module\n\n    ```bash\n    python -m venv venv\n    . ./venv/bin/activate\n    pip install \"st4sd-runtime-core[develop]\"\n    ```\n- A local copy of https://github.com/st4sd/st4sd-examples\n\n    Clone the github repository and then cd into its sub-directory `tutorials/2-write-advanced-experiments`\n\n    ```bash\n    git clone https://github.com/st4sd/st4sd-examples.git\n    ```\n\n## An experiment that has key-outputs\n\nAll experiments produce files, but not all generated files are equally important. To this end ST4SD has the concept of key-outputs. These are files, and directories, that an experiment produces which the developers of the experiment consider important.\n\n<InlineNotification kind=\"info\">\n\nMake sure your working directory is the sub-directory `tutorials/2-write-experiments` of the directory you stored https://github.com/st4sd/st4sd-examples in.\n\n</InlineNotification>\n\n\nHere is a an example of an experiment with a key-output:\n\n\n```yaml\nentrypoint:\n  entry-instance: hello\n  execute:\n  - target: <entry-instance>\n    args:\n      message: Hello world\n  output:\n    - name: greeting\n      data-in: <entry-instance>:output\n      description: just a friendly greeting\n\ncomponents:\n- signature:\n    name: hello\n    parameters:\n      - name: message\n  command:\n    executable: echo\n    arguments: \"%(message)s\"\n\n```\n\nFile: `0-key-outputs.yaml`\n\n\nRun it like so:\n\n```commandline\nelaunch.py -l40 --nostamp 0-key-outputs.yaml\n```\n\nThe `output` field in the `entrypoint` dictionary defines the key-outputs of this experiment:\n\n```yaml\nentrypoint:\n  # ... other fields ...\n  output:\n    - name: greeting\n      data-in: <entry-instance>:output\n```\n\nThis experiment has a single key-output called `greeting`. The data associated with this key-output is actually the `stdout` of the `<entry-instance>` step which is an instance of the `hello` component. As the experiment finishes producing this key-output the `$INSTANCE_DIR/output/output.json` file is updated to reflect the state of this experiment.\n\nHere's an example of `output.json`:\n\n```json\n{\n    \"greeting\": {\n        \"creationtime\": \"1725374555.6836693\",\n        \"description\": \"just a friendly greeting\",\n        \"filename\": \"out.stdout\",\n        \"filepath\": \"stages/stage0/entry-instance/out.stdout\",\n        \"final\": \"yes\",\n        \"production\": \"yes\",\n        \"type\": \"\",\n        \"version\": \"1\"\n    }\n}\n```\n\nWhile the experiment is running, the runtime system asynchronously updates this file with metadata about the generated key-outputs of the experiment. In this example, there is just one key-output called `greeting`. For more information on key-outputs check out our [documentation](/workflow-specification#key-outputs).\n\nIf you are running experiments on the cloud and are instructing the runtime system to register them into the ST4SD datastore you may also use the ST4SD python API to [download](/running-workflows-on-openshift#retrieving-the-outputs-of-a-virtual-experiment-instance) the key-outputs of your experiment instances.\n\n### Exercises\n\n- Use `elaunch.py` to run `0-key-outputs.yaml` and look at the file containing the key-output metadata.\n- Write a new experiment that has a single component called nested inside a workflow. See the example on [nested workflows](/write-experiments#your-first-multi-step-experiment) to refresh your memory on how to write experiments that contain both Workflow and Component templates. Add a key-output which points to the stdout of your component (use an [OutputReference](/workflow-specification-dsl#outputreference) that points to the `:output` of your component's instance).\n\n\n## An experiment that has an interface\n\nSome virtual experiments define interfaces which make it simpler for users to retrieve the input systems and measured properties from executions of that virtual experiment\n\nThe `interface` of a virtual experiment defines:\n\n- The specification used to describe `input` systems it processes e.g. SMILEs for small molecules\n- Instructions to extract the `input` systems from input data\n- Instructions to extract the values of `properties` that the virtual experiment computes\n\nOnce a virtual experiment has an `interface`  ST4SD can return a `pandas.DataFrame`  containing the properties calculated by instances of the virtual experiment, as well as the ids of the `input` systems that an instance processed. This functionality is provided via the `st4sd-datastore` API and the `st4sd-runtime-service` API. See [using a virtual experiment interface](/using-a-virtual-experiment-interface) for further information.\n\n\nIn this example we will work with a virtual experiment which:\n1. extracts the IDs of its input systems\n2. has 2 key-outputs that correspond to 2 measured properties of the interface\n3. uses builtin hooks to extract the measured properties from the key-outputs\n\nThe DSL of the experiment is :\n\n```yaml\nentrypoint:\n  interface:\n    description: Counts vowels in words\n    inputSpec:\n      namingScheme: words\n      inputExtractionMethod:\n        csvColumn:\n          source:\n            path: input/words.csv\n          args:\n            column: word\n    propertiesSpec:\n    - name: Vowels\n      propertyExtractionMethod:\n        csvDataFrame:\n          source:\n            keyOutput: vowels\n          args:\n            renameColumns:\n              word: input-id\n            usecols:\n            - word\n            - vowels\n    - name: Letters\n      propertyExtractionMethod:\n        csvDataFrame:\n          source:\n            keyOutput: letters\n          args:\n            renameColumns:\n              word: input-id\n            usecols:\n            - word\n            - letters\n  output:\n    - name: vowels\n      data-in: <entry-instance/count-vowels>/vowels.csv:ref\n    - name: letters\n      data-in: <entry-instance/count-letters>/letters.csv:ref\n\n  entry-instance: main\n  execute:\n    - target: <entry-instance>\n      args:\n        words_file: input/words.csv:ref\n\nworkflows:\n  - signature:\n      name: main\n      parameters:\n        - name: words_file\n    steps:\n      count-vowels: count-vowels\n      count-letters: count-letters\n    execute:\n      - target: <count-vowels>\n        args:\n          words: \"%(words_file)s\"\n      - target: <count-letters>\n        args:\n          words: \"%(words_file)s\"\n\ncomponents:\n- signature:\n    name: count-vowels\n    parameters:\n    - name: words\n  command:\n    executable: bin/count_vowels.py\n    arguments: \"%(words)s\"\n\n- signature:\n    name: count-letters\n    parameters:\n      - name: words\n  command:\n    executable: bin/count_letters.py\n    arguments: \"%(words)s\"\n```\n\nFile: `1-interface.package/conf/dsl.yaml`\n\n\nThe interface contains a human readable description of the experiment under `entrypoint.interface.description`.\n\n```yaml\nentrypoint:\n  interface:\n    description: Counts vowels in words\n```\n\nThen, in `entrypoint.interface.inputspec` it uses the builtin input extraction method `csvColumn` to extract the ids of the systems it processes:\n\n```yaml\nentrypoint:\n  interface:\n    inputSpec:\n      namingScheme: words\n      inputExtractionMethod:\n        csvColumn:\n          source:\n            path: input/words.csv\n          args:\n            column: word\n```\n\nIt instructs the method to read the CSV file `input/words.csv` (i.e. the input file) and treat every row of the CSV as one input system whose identifier lies in the column `word`.\n\nFollowing that, it uses the builtin property extraction method `csvDataFrame` twice to measure its 2 properties `Vowels` and `Letters` from the key-outputs `vowels` and `letters` respectively.\n\n```yaml\nentrypoint:\n  interface:\n    propertiesSpec:\n    - name: Vowels\n      propertyExtractionMethod:\n        csvDataFrame:\n          source:\n            keyOutput: vowels\n          args:\n            renameColumns:\n              word: input-id\n            usecols:\n            - word\n            - vowels\n    - name: Letters\n      propertyExtractionMethod:\n        csvDataFrame:\n          source:\n            keyOutput: letters\n          args:\n            renameColumns:\n              word: input-id\n            usecols:\n            - word\n            - letters\n```\n\nThe [`csvDataFrame`](/writing-a-virtual-experiment-interface#csvdataframe) property extraction method expects a CSV file which has the columns `input-id` and `${the property name}`. One of the requirements for using a ST4SD interface is that the property names start with a capital letter. One of the requirements of the `csvDataFrame` is that there should be a column with the same name as the property name that is being extracted. Another is that there should be a column called `input-id`.\n\nIn this example the components happen to produce key-output CSV files which contain a properly named column for the values of properties but instead of using the `input-id` column they use the column `word`. To account for this inconsistency, the developers of the workflow use the `renameColumns` argument of the `csvDataFrame` property extraction method. Via `renameColumns` they instruct `csvDataFrame` to treat the column `word` as if it were called `input-id`.\n\nNotice that the entrypoint expects an input file called `words.csv`:\n\n```yaml\nentrypoint:\n    ...\n    execute:\n    - target: <entry-instance>\n      args:\n        words_file: input/words.csv:ref\n```\n\nThis means that you have to create a CSV file called `words.csv` and use it as an input for (via the `-i` arg) to the workflow.\n\nTo run this experiment, you can copy/paste the following to your terminal:\n\n```bash\n: create the input file\ncat<<EOF >words.csv\nword;\nhello;\nawesome;\nworld;\nEOF\n\n: launch the experiment\nelaunch.py -l 20 -i words.csv 1-interface.package\n```\n\nIf you are running experiments on the cloud and are instructing the runtime system to register them into the ST4SD datastore you may also use the ST4SD python API to [download](/using-a-virtual-experiment-interface#getting-the-properties) the measured properties of your experiment instances.\n\n## Exercises\n\n- Use `elaunch.py` to run `1-interface.package`. Then look at the files:\n    - `$INSTANCE_DIR/output/output.json`\n    - `$INSTANCE_DIR/output/input-ids.json`\n    - `$INSTANCE_DIR/output/properties.csv`\n- Update the experiment to use a custom python hook for extracting the measured properties from the key-outputs. The documentation for the `hookGetProperties` hook is [here](/writing-a-virtual-experiment-interface#hookgetproperties).\n\n\n## What's next?\n\n- More information on running experiments directly, i.e. via `elaunch.py` [here](https://st4sd.github.io/overview/direct-run)\n- More information on the DSL of ST4SD i.e. how to write experiments [here](https://st4sd.github.io/overview/workflow-specification-dsl)\n- More information on how to structure and test your experiments [here](https://st4sd.github.io/overview/packaging-workflows/)\n- More information on writing experiments with interfaces [here](/writing-a-virtual-experiment-interface).","type":"Mdx","contentDigest":"09003119f41e09a3966459ea16071369","owner":"gatsby-plugin-mdx","counter":279},"frontmatter":{"title":"Write Advanced Experiments"},"exports":{},"rawBody":"---\ntitle: Write Advanced Experiments\n---\n\nimport { CarbonForIbmDotcom } from \"@carbon/pictograms-react\";\nimport { ArtTools_01 } from \"@carbon/pictograms-react\";\n\n<!--\n\n  Copyright IBM Inc. All Rights Reserved.\n  SPDX-License-Identifier: Apache-2.0\n\n-->\n\n<PageDescription>\n\nSpend up to 60 minutes learning how to write experiments that utilize some of the advanced features of ST4SD. This page assumes you are familiar with writing basic experiments and running them locally using the elaunch.py command line tool. If you need a refresher take a moment to read our [docs](/write-experiments) before continuing any further.\n\n</PageDescription>\n\n\n<AnchorLinks>\n\n  <AnchorLink>Requirements</AnchorLink>\n  <AnchorLink>An experiment that has key-outputs</AnchorLink>\n  <AnchorLink>An experiment that has an interface</AnchorLink>\n</AnchorLinks>\n\n\n\n### Requirements\n\n- An understanding of [how to run a ST4SD workflow locally](/direct-run).\n- An understanding of [how to write a basic ST4SD workflow](/write-experiments)\n- A python 3.9+ interpreter\n- A virtual environment with the `st4sd-runtime-core` python module\n\n    ```bash\n    python -m venv venv\n    . ./venv/bin/activate\n    pip install \"st4sd-runtime-core[develop]\"\n    ```\n- A local copy of https://github.com/st4sd/st4sd-examples\n\n    Clone the github repository and then cd into its sub-directory `tutorials/2-write-advanced-experiments`\n\n    ```bash\n    git clone https://github.com/st4sd/st4sd-examples.git\n    ```\n\n## An experiment that has key-outputs\n\nAll experiments produce files, but not all generated files are equally important. To this end ST4SD has the concept of key-outputs. These are files, and directories, that an experiment produces which the developers of the experiment consider important.\n\n<InlineNotification kind=\"info\">\n\nMake sure your working directory is the sub-directory `tutorials/2-write-experiments` of the directory you stored https://github.com/st4sd/st4sd-examples in.\n\n</InlineNotification>\n\n\nHere is a an example of an experiment with a key-output:\n\n\n```yaml\nentrypoint:\n  entry-instance: hello\n  execute:\n  - target: <entry-instance>\n    args:\n      message: Hello world\n  output:\n    - name: greeting\n      data-in: <entry-instance>:output\n      description: just a friendly greeting\n\ncomponents:\n- signature:\n    name: hello\n    parameters:\n      - name: message\n  command:\n    executable: echo\n    arguments: \"%(message)s\"\n\n```\n\nFile: `0-key-outputs.yaml`\n\n\nRun it like so:\n\n```commandline\nelaunch.py -l40 --nostamp 0-key-outputs.yaml\n```\n\nThe `output` field in the `entrypoint` dictionary defines the key-outputs of this experiment:\n\n```yaml\nentrypoint:\n  # ... other fields ...\n  output:\n    - name: greeting\n      data-in: <entry-instance>:output\n```\n\nThis experiment has a single key-output called `greeting`. The data associated with this key-output is actually the `stdout` of the `<entry-instance>` step which is an instance of the `hello` component. As the experiment finishes producing this key-output the `$INSTANCE_DIR/output/output.json` file is updated to reflect the state of this experiment.\n\nHere's an example of `output.json`:\n\n```json\n{\n    \"greeting\": {\n        \"creationtime\": \"1725374555.6836693\",\n        \"description\": \"just a friendly greeting\",\n        \"filename\": \"out.stdout\",\n        \"filepath\": \"stages/stage0/entry-instance/out.stdout\",\n        \"final\": \"yes\",\n        \"production\": \"yes\",\n        \"type\": \"\",\n        \"version\": \"1\"\n    }\n}\n```\n\nWhile the experiment is running, the runtime system asynchronously updates this file with metadata about the generated key-outputs of the experiment. In this example, there is just one key-output called `greeting`. For more information on key-outputs check out our [documentation](/workflow-specification#key-outputs).\n\nIf you are running experiments on the cloud and are instructing the runtime system to register them into the ST4SD datastore you may also use the ST4SD python API to [download](/running-workflows-on-openshift#retrieving-the-outputs-of-a-virtual-experiment-instance) the key-outputs of your experiment instances.\n\n### Exercises\n\n- Use `elaunch.py` to run `0-key-outputs.yaml` and look at the file containing the key-output metadata.\n- Write a new experiment that has a single component called nested inside a workflow. See the example on [nested workflows](/write-experiments#your-first-multi-step-experiment) to refresh your memory on how to write experiments that contain both Workflow and Component templates. Add a key-output which points to the stdout of your component (use an [OutputReference](/workflow-specification-dsl#outputreference) that points to the `:output` of your component's instance).\n\n\n## An experiment that has an interface\n\nSome virtual experiments define interfaces which make it simpler for users to retrieve the input systems and measured properties from executions of that virtual experiment\n\nThe `interface` of a virtual experiment defines:\n\n- The specification used to describe `input` systems it processes e.g. SMILEs for small molecules\n- Instructions to extract the `input` systems from input data\n- Instructions to extract the values of `properties` that the virtual experiment computes\n\nOnce a virtual experiment has an `interface`  ST4SD can return a `pandas.DataFrame`  containing the properties calculated by instances of the virtual experiment, as well as the ids of the `input` systems that an instance processed. This functionality is provided via the `st4sd-datastore` API and the `st4sd-runtime-service` API. See [using a virtual experiment interface](/using-a-virtual-experiment-interface) for further information.\n\n\nIn this example we will work with a virtual experiment which:\n1. extracts the IDs of its input systems\n2. has 2 key-outputs that correspond to 2 measured properties of the interface\n3. uses builtin hooks to extract the measured properties from the key-outputs\n\nThe DSL of the experiment is :\n\n```yaml\nentrypoint:\n  interface:\n    description: Counts vowels in words\n    inputSpec:\n      namingScheme: words\n      inputExtractionMethod:\n        csvColumn:\n          source:\n            path: input/words.csv\n          args:\n            column: word\n    propertiesSpec:\n    - name: Vowels\n      propertyExtractionMethod:\n        csvDataFrame:\n          source:\n            keyOutput: vowels\n          args:\n            renameColumns:\n              word: input-id\n            usecols:\n            - word\n            - vowels\n    - name: Letters\n      propertyExtractionMethod:\n        csvDataFrame:\n          source:\n            keyOutput: letters\n          args:\n            renameColumns:\n              word: input-id\n            usecols:\n            - word\n            - letters\n  output:\n    - name: vowels\n      data-in: <entry-instance/count-vowels>/vowels.csv:ref\n    - name: letters\n      data-in: <entry-instance/count-letters>/letters.csv:ref\n\n  entry-instance: main\n  execute:\n    - target: <entry-instance>\n      args:\n        words_file: input/words.csv:ref\n\nworkflows:\n  - signature:\n      name: main\n      parameters:\n        - name: words_file\n    steps:\n      count-vowels: count-vowels\n      count-letters: count-letters\n    execute:\n      - target: <count-vowels>\n        args:\n          words: \"%(words_file)s\"\n      - target: <count-letters>\n        args:\n          words: \"%(words_file)s\"\n\ncomponents:\n- signature:\n    name: count-vowels\n    parameters:\n    - name: words\n  command:\n    executable: bin/count_vowels.py\n    arguments: \"%(words)s\"\n\n- signature:\n    name: count-letters\n    parameters:\n      - name: words\n  command:\n    executable: bin/count_letters.py\n    arguments: \"%(words)s\"\n```\n\nFile: `1-interface.package/conf/dsl.yaml`\n\n\nThe interface contains a human readable description of the experiment under `entrypoint.interface.description`.\n\n```yaml\nentrypoint:\n  interface:\n    description: Counts vowels in words\n```\n\nThen, in `entrypoint.interface.inputspec` it uses the builtin input extraction method `csvColumn` to extract the ids of the systems it processes:\n\n```yaml\nentrypoint:\n  interface:\n    inputSpec:\n      namingScheme: words\n      inputExtractionMethod:\n        csvColumn:\n          source:\n            path: input/words.csv\n          args:\n            column: word\n```\n\nIt instructs the method to read the CSV file `input/words.csv` (i.e. the input file) and treat every row of the CSV as one input system whose identifier lies in the column `word`.\n\nFollowing that, it uses the builtin property extraction method `csvDataFrame` twice to measure its 2 properties `Vowels` and `Letters` from the key-outputs `vowels` and `letters` respectively.\n\n```yaml\nentrypoint:\n  interface:\n    propertiesSpec:\n    - name: Vowels\n      propertyExtractionMethod:\n        csvDataFrame:\n          source:\n            keyOutput: vowels\n          args:\n            renameColumns:\n              word: input-id\n            usecols:\n            - word\n            - vowels\n    - name: Letters\n      propertyExtractionMethod:\n        csvDataFrame:\n          source:\n            keyOutput: letters\n          args:\n            renameColumns:\n              word: input-id\n            usecols:\n            - word\n            - letters\n```\n\nThe [`csvDataFrame`](/writing-a-virtual-experiment-interface#csvdataframe) property extraction method expects a CSV file which has the columns `input-id` and `${the property name}`. One of the requirements for using a ST4SD interface is that the property names start with a capital letter. One of the requirements of the `csvDataFrame` is that there should be a column with the same name as the property name that is being extracted. Another is that there should be a column called `input-id`.\n\nIn this example the components happen to produce key-output CSV files which contain a properly named column for the values of properties but instead of using the `input-id` column they use the column `word`. To account for this inconsistency, the developers of the workflow use the `renameColumns` argument of the `csvDataFrame` property extraction method. Via `renameColumns` they instruct `csvDataFrame` to treat the column `word` as if it were called `input-id`.\n\nNotice that the entrypoint expects an input file called `words.csv`:\n\n```yaml\nentrypoint:\n    ...\n    execute:\n    - target: <entry-instance>\n      args:\n        words_file: input/words.csv:ref\n```\n\nThis means that you have to create a CSV file called `words.csv` and use it as an input for (via the `-i` arg) to the workflow.\n\nTo run this experiment, you can copy/paste the following to your terminal:\n\n```bash\n: create the input file\ncat<<EOF >words.csv\nword;\nhello;\nawesome;\nworld;\nEOF\n\n: launch the experiment\nelaunch.py -l 20 -i words.csv 1-interface.package\n```\n\nIf you are running experiments on the cloud and are instructing the runtime system to register them into the ST4SD datastore you may also use the ST4SD python API to [download](/using-a-virtual-experiment-interface#getting-the-properties) the measured properties of your experiment instances.\n\n## Exercises\n\n- Use `elaunch.py` to run `1-interface.package`. Then look at the files:\n    - `$INSTANCE_DIR/output/output.json`\n    - `$INSTANCE_DIR/output/input-ids.json`\n    - `$INSTANCE_DIR/output/properties.csv`\n- Update the experiment to use a custom python hook for extracting the measured properties from the key-outputs. The documentation for the `hookGetProperties` hook is [here](/writing-a-virtual-experiment-interface#hookgetproperties).\n\n\n## What's next?\n\n- More information on running experiments directly, i.e. via `elaunch.py` [here](https://st4sd.github.io/overview/direct-run)\n- More information on the DSL of ST4SD i.e. how to write experiments [here](https://st4sd.github.io/overview/workflow-specification-dsl)\n- More information on how to structure and test your experiments [here](https://st4sd.github.io/overview/packaging-workflows/)\n- More information on writing experiments with interfaces [here](/writing-a-virtual-experiment-interface).","fileAbsolutePath":"/home/travis/build/st4sd/overview/src/pages/write-advanced-experiments.mdx"}}},"staticQueryHashes":["1364590287","137577622","2102389209","2456312558","2746626797","3018647132","3037994772","768070550"]}