{"componentChunkName":"component---src-pages-workflow-specification-dsl-mdx","path":"/workflow-specification-dsl/","result":{"pageContext":{"frontmatter":{"title":"DSL 2.0 Specification"},"relativePagePath":"/workflow-specification-dsl.mdx","titleType":"page","MdxNode":{"id":"539ee079-e5d4-5b79-bca7-6a8c3ec03fda","children":[],"parent":"28e64c8c-1b2e-58e9-9b28-24244775469f","internal":{"content":"---\ntitle: DSL 2.0 Specification\n---\n\n<!--\n\n  Copyright IBM Inc. All Rights Reserved.\n  SPDX-License-Identifier: Apache-2.0\n\n-->\n\n<PageDescription>\n\nUse this page to learn about the new Domain Specific Language (DSL 2.0) of ST4SD and how it works.\n\n</PageDescription>\n\n\n<InlineNotification kind=\"info\">\n\nHere, we are using DSL 2.0, if you need to understand the previous syntax check out the [FlowIR docs](/workflow-specification).\n\n</InlineNotification>\n\n<AnchorLinks>\n    <AnchorLink>Namespace</AnchorLink>\n    <AnchorLink>Entrypoint</AnchorLink>\n    <AnchorLink>Workflow</AnchorLink>\n    <AnchorLink>Component</AnchorLink>\n    <AnchorLink>Assigning values to parameters</AnchorLink>\n    <AnchorLink>OutputReference</AnchorLink>\n    <AnchorLink>Example</AnchorLink>\n    <AnchorLink>Key outputs</AnchorLink>\n    <AnchorLink>Interface</AnchorLink>\n    <AnchorLink>Differences between DSL 2.0 and FlowIR</AnchorLink>\n</AnchorLinks>\n\nDSL 2.0 is the new (and beta) way to define the computational graphs of ST4SD workflows.\n\n## Namespace\n\nIn DSL 2.0, a Computational Graph consists of Components which can be grouped under Workflow containers. \nIt also has an Entrypoint which points to the root node of the graph, which is an instance of a Component or Workflow template.\n\nA Namespace is simply a container for the Component, Workflow, and Entrypoint definitions which represent the Computational Graph of one ST4SD workflow. \n\nBelow is an example of a Namespace containing a single component that prints the message `Hello world` to the terminal.\n\n```yaml\nentrypoint:\n  entry-instance: print\n  execute:\n  - target: \"<entry-instance>\"\n    args:\n      message: Hello world\ncomponents:\n- signature:\n    name: print\n    parameters:\n      name: message\n  command:\n    executable: echo\n    arguments: \"%(message)s\"\n```\n\n## Entrypoint\n\nThe Optional Entrypoint serves a single purpose. Describe how to execute root Template instance of the Computational Graph.\n\nIts schema is:\n\n```yaml\n# This executes an instance of $template which is called \"<entry-instance>\"\nentry-instance: $template # name of a Component or Workflow template\nexecute: # an array with exactly 1 entry\n- target: <entry-instance> # which instance of a Template to execute.\n                           # In this scope there is only <entry-instance>\n  args:\n    $paramName: $value # one for each parameter of the template that\n                       # the \"target\" points to\n```\n\nThe `entry-instance` field receives the name of a Template and creates an instance of it called `<entry-instance>`.\nThe `execute` field then describes how to \"execute\" the `<entry-instance>` i.e. how to populate the arguments of the associated Template.\n\nIn `execute[].args` you:\n\n* **must** provide values for any parameters in the child `$template` which do not have default values\n* **may** override the value of the parameters in `$template` which have default values\n\nThe Template instance that the entrypoint points to can have special parameters which are data references to paths that are external to the workflow.\nThese parameters must be called `input.$filename` and they must not have default values in the signature of the Template definition.\nThe entrypoint **may** not explicitly override the values of said parameters, the runtime system will auto-generate them.\n\nConsider a scenario where the Template that the `<entry-instance>` step points to has a parameter called `input.my-input.db`. \nThe runtime will post-process the `entrypoint.execute[0].args` dictionary to include the following key-value pair:\n\n```yaml\ninput.my-input.db: \"input/my-input.db\"\n```\n\nIn [Assigning values to parameters](#assigning-values-to-parameters) we describe in more detail how to assign values to parameters of Template instances in general.\n\n\n## Workflow\n\nA Workflow is a Template that describes how to `execute` a number of Template instances called `steps`.\nIt has a `signature` that consists of a unique `name` and a `parameter` list. \nEach such step can consume the outputs of a sibling step, or the parameters of the parent Workflow.\n\nThe outputs of a workflow are its `steps`. The schema of Workflow is:\n\n```yaml\nsignature:\n  name: $Template # the name of this Workflow Template - must be unique\n  parameters:\n    - name: $paramName\n      # optional default value\n      default: $value # str, number, or dictionary of {str: str/number}\nsteps: # which steps to instantiate\n  $stepName: $Template # for example child: simulation-code\nexecute: # how to execute the steps - one for each entry of steps\n- target: <$stepName> # for example <child> or <child/grandchild>\n  args:\n    $paramName: $value # one for each parameter of the Template that\n                       # .target points to\n```\n\nIn [Assigning values to parameters](#assigning-values-to-parameters) we describe how to assign values to parameters of Template instances.\n\n## Component\n\nA Component describes how to `execute` a task.\nJust like a Workflow Template, it has a `signature` that consists of a `name` and a `parameter` list. \n\nThe outputs of a Component are the paths under its working directory. \n\nThe schema of a Component is:\n\n```yaml\nsignature:\n  name: $Template # the name of this Component Template - must be unique\n  parameters:\n    - name: $paramName\n      # optional default value\n      default: $value # str, number, or dictionary of {str: str/number}\n# All the FlowIR fields, except for stage, name, references, and override\ncommand:\n  executable: str\n  arguments: str\n  environment: (null, str)\nworkflowAttributes:\n  aggregate: bool\n  replicate: (int, null, str containing %(value-reference)s)\nresourceRequest:\n  numberProcesses: (int, str containing %(value-reference)s)\n  numberThreads: (int, str containing %(value-reference)s)\n  ranksPerNode: (int, str containing %(value-reference)s)\n  threadsPerCore: (int, str containing %(value-reference)s)\n  memory: (int (size in bytes), str containing %(value-reference)s or Mib/Kib bytes )\n  gpus: (int, str containing %(value-reference)s)\nresourceManager:\n  config:\n    backend: (name of backend e.g local, kubernetes, lsf, docker)\n    walltime: (in minutes, valid for \"kubernetes\" and \"lsf\" backends, float)\n  docker:\n    image: str\n    imagePullPolicy: (Optional) one of Always (default), Never, IfNotPresent\n  kubernetes:\n    image: str\n  lsf:\n    queue: str\nvariables:\n  <variable name:str>: <value: str, int, bool, float>\n```\n\nThe above fields are the same as those in the [Component section of the Workflow Specification in FlowIR](/workflow-specification/#component).\n\nFor more information, read our documentation on the [basic FlowIR component fields](/workflow-specification#description-of-basic-flowir-component-fields).\n\n## Assigning values to parameters\n\nBoth Component and Workflow templates are instantiated in the same way: \nby declaring them as a `step` and adding an entry to an `execute` block which assigns values to the Template's parameters.\n\nThe value of a parameter can be a number, string, or a key: value dictionary. \nThe body of a Template can reference its parameters like so `%(parameterName)s`.\n\nWhen assigning a value to the parameters of a template via the `execute[].args` dictionary\n\nIn `execute[].args` you:\n\n* **must** provide values for any parameters in the child `$template` which do not have default values\n* **may** override the value of the parameters in `$template` which have default values\n* **may** use `OutputReferences` to indicate dependencies to steps (definition follows this bullet list)\n* **may** use `%(parentParameter)s` to indicate a dependency to the value that the parent parameter has. In turn that can be a dependency to the output of a Template instance or an input file or it might just be a literal constant\n* **may** use a `$key: $value` dictionary to propagate a dictionary-type value. At the moment Template can only reference this kind of parameters to set the value of the `command.environment` field of Components\n* **may** use `%(input.$filename)s`to propagate an input file reference from a parent to a step. \n  - Eventually a step must apply a [DataReferences](/workflow-specification/#datareference) `:$method` to the parameter to indicates it wishes to consume the input file\n\n### Environments\n\nThe environment that components run in is defined in the `command.environment` field. If you don't define anything in this section ST4SD will create a default environment containing all the environment variables of the runtime system process.\n\nExample:\n\n```yaml\ncommand:\n  environment:\n    ENV-VAR1: value/for/env-var1\n    ENV-VAR2: value/for/env-var2\n    DEFAULTS: ENV-VAR3:ENV-VAR4\n```\n\nThe above defines an environment with 4 environment variables:\n\n- `ENV-VAR1` whose value is `value/for/env-var1`\n- `ENV-VAR2` whose value is `value/for/env-var2`\n- `ENV-VAR3` whose value is inherited from the environment variable `ENV-VAR3` of the process running the runtime system\n- `ENV-VAR4` whose value is inherited from the environment variable `ENV-VAR4` of the process running the runtime system\n\nIn the above example, we use the `DEFAULTS` directive to inherit the values for a list of environment variables from the environment variables of the runtime system process. The value of the special \"DEFAULTS\" key is a list of environment variable name separated with \":\".\n\nWant to find out more? Check out our [example](#example).\n\n### OutputReference\n\nThe format of an `OutputReference` is:\n\n```\n<$stepId>/$optionalPath:$optionalMethod\n```\n\n`$stepId` is a `/` separated array of `stepNames` starting from the scope of the current workflow. For example, the OutputReference `<one/child>/file.txt:ref` resolves to the absolute path of the file `file.txt` that the component `child` produces under the sibling step `one` which is an instance of a Workflow template. You can find more reference `methods` in our [DataReferences](/workflow-specification/#datareference) docs.\n\n\n\n\n# Example\n\nHere is a simple example which uses one Workflow and one Component template two run 2 tasks.\n\n- consume-input: prints the contents of an input file called `my-input.db`\n- consume-sibling: prints the text \"my sibling said\" followed by stdout of the sibling step `<consume-input>` \n\n```yaml\nentrypoint:\n  entry-instance: main\n  execute:\n  - target: <entry-instance>\nworkflows:\n- signature:\n    name: main\n    parameters:\n    # special variable with auto-populated value\n    - name: input.my-input.db\n  steps:\n    consume-input: echo\n    consume-sibling: echo\n  execute:\n    - target: <consume-input>\n      args:\n        # resolves to the contents of the file \n        # that input.my-input-d points to\n        message: \"%(input.my-input.db)s:output\"\n    - target: <consume-sibling>\n      args:\n        # resolves to the stdout of step consume-input\n        message: \"my sibling said <consume-input>:output\"\ncomponents:\n- signature:\n    name: echo\n    parameters:\n      - name: message\n  command:\n    executable: \"echo\"\n    arguments: \"%(message)s\"\n```\n\n\nTo try it out, store the above DSL in a file called `dsl-params.yaml` and run\n\n```\npip install \"st4sd-runtime-core[develop]>=2.5.1\"\n```\n\nwhich installs the command-line-tool elaunch.py, followed by:\n\n```bash\necho \"hello world\" >my-input.db\nelaunch.py -i my-input.db --failSafeDelays=no -l40 dsl-params.yaml\n```\n\n## Key outputs\n\nAll experiments produce files, but not all generated files are equally important. To this end ST4SD has the concept of key-outputs. These are files, and directories, that an experiment produces which the developers of the experiment consider important.\n\n\nHere is a an example of an experiment with a key-output:\n\n\n```yaml\nentrypoint:\n  entry-instance: hello\n  execute:\n  - target: <entry-instance>\n    args:\n      message: Hello world\n  output:\n    - name: greeting\n      data-in: <entry-instance>:output\n      description: just a friendly greeting\n\ncomponents:\n- signature:\n    name: hello\n    parameters:\n      - name: message\n  command:\n    executable: echo\n    arguments: \"%(message)s\"\n\n```\n\nThe `output` field in the `entrypoint` dictionary defines the key-outputs of this experiment:\n\n```yaml\nentrypoint:\n  # ... other fields ...\n  output:\n    - name: greeting\n      data-in: <entry-instance>:output\n```\n\nThis experiment has a single key-output called `greeting`. The data associated with this key-output is actually the `stdout` of the `<entry-instance>` step which is an instance of the `hello` component. As the experiment finishes producing this key-output the `$INSTANCE_DIR/output/output.json` file is updated to reflect the state of this experiment.\n\nHere's an how the `output.json` file will look like for the above key outputs:\n\n```json\n{\n    \"greeting\": {\n        \"creationtime\": \"1725374555.6836693\",\n        \"description\": \"just a friendly greeting\",\n        \"filename\": \"out.stdout\",\n        \"filepath\": \"stages/stage0/entry-instance/out.stdout\",\n        \"final\": \"yes\",\n        \"production\": \"yes\",\n        \"type\": \"\",\n        \"version\": \"1\"\n    }\n}\n```\n\nWhile the experiment is running, the runtime system asynchronously updates this file with metadata about the generated key-outputs of the experiment. In this example, there is just one key-output called `greeting`. For more information on key-outputs check out our [documentation](/workflow-specification#key-outputs).\n\nIf you are running experiments on the cloud and are instructing the runtime system to register them into the ST4SD datastore you may also use the ST4SD python API to [download](/running-workflows-on-openshift#retrieving-the-outputs-of-a-virtual-experiment-instance) the key-outputs of your experiment instances.\n\n## Interface\n\nKey outputs are not always immediately parseable without deep understanding of their format. To address this, ST4SD supports the **interface** feature. This feature allows workflow developers to extract measured properties and store them in a CSV file, making the data easier to consume.\n\n\nSome virtual experiments define interfaces which make it simpler for users to retrieve the input systems and measured properties from executions of that virtual experiment.\n\nThe `interface` of a virtual experiment defines:\n\n- The specification used to describe `input` systems it processes e.g. SMILEs for small molecules\n- Instructions to extract the `input` systems from input data\n- Instructions to extract the values of `properties` that the virtual experiment computes\n\nOnce a virtual experiment has an `interface`  ST4SD can return a `pandas.DataFrame`  containing the properties calculated by instances of the virtual experiment, as well as the ids of the `input` systems that an instance processed. This functionality is provided via the `st4sd-datastore` API and the `st4sd-runtime-service` API. See [using a virtual experiment interface](/using-a-virtual-experiment-interface) for further information.\n\n\nIn this example we will work with a virtual experiment which:\n1. extracts the IDs of its input systems\n2. has 2 key-outputs that correspond to 2 measured properties of the interface\n3. uses builtin hooks to extract the measured properties from the key-outputs\n\nThe DSL of the experiment is :\n\n```yaml\nentrypoint:\n  interface:\n    description: Counts vowels in words\n    inputSpec:\n      namingScheme: words\n      inputExtractionMethod:\n        csvColumn:\n          source:\n            path: input/words.csv\n          args:\n            column: word\n    propertiesSpec:\n    - name: Vowels\n      propertyExtractionMethod:\n        csvDataFrame:\n          source:\n            keyOutput: vowels\n          args:\n            renameColumns:\n              word: input-id\n            usecols:\n            - word\n            - vowels\n    - name: Letters\n      propertyExtractionMethod:\n        csvDataFrame:\n          source:\n            keyOutput: letters\n          args:\n            renameColumns:\n              word: input-id\n            usecols:\n            - word\n            - letters\n  output:\n    - name: vowels\n      data-in: <entry-instance/count-vowels>/vowels.csv:ref\n    - name: letters\n      data-in: <entry-instance/count-letters>/letters.csv:ref\n\n  entry-instance: main\n  execute:\n    - target: <entry-instance>\n      args:\n        words_file: input/words.csv:ref\n\nworkflows:\n  - signature:\n      name: main\n      parameters:\n        - name: words_file\n    steps:\n      count-vowels: count-vowels\n      count-letters: count-letters\n    execute:\n      - target: <count-vowels>\n        args:\n          words: \"%(words_file)s\"\n      - target: <count-letters>\n        args:\n          words: \"%(words_file)s\"\n\ncomponents:\n- signature:\n    name: count-vowels\n    parameters:\n    - name: words\n  command:\n    executable: bin/count_vowels.py\n    arguments: \"%(words)s\"\n\n- signature:\n    name: count-letters\n    parameters:\n      - name: words\n  command:\n    executable: bin/count_letters.py\n    arguments: \"%(words)s\"\n```\n\n\nThe interface contains a human readable description of the experiment under `entrypoint.interface.description`.\n\n```yaml\nentrypoint:\n  interface:\n    description: Counts vowels in words\n```\n\nThen, in `entrypoint.interface.inputspec` it uses the builtin input extraction method `csvColumn` to extract the ids of the systems it processes:\n\n```yaml\nentrypoint:\n  interface:\n    inputSpec:\n      namingScheme: words\n      inputExtractionMethod:\n        csvColumn:\n          source:\n            path: input/words.csv\n          args:\n            column: word\n```\n\nIt instructs the method to read the CSV file `input/words.csv` (i.e. the input file) and treat every row of the CSV as one input system whose identifier lies in the column `word`.\n\nFollowing that, it uses the builtin property extraction method `csvDataFrame` twice to measure its 2 properties `Vowels` and `Letters` from the key-outputs `vowels` and `letters` respectively.\n\n```yaml\nentrypoint:\n  interface:\n    propertiesSpec:\n    - name: Vowels\n      propertyExtractionMethod:\n        csvDataFrame:\n          source:\n            keyOutput: vowels\n          args:\n            renameColumns:\n              word: input-id\n            usecols:\n            - word\n            - vowels\n    - name: Letters\n      propertyExtractionMethod:\n        csvDataFrame:\n          source:\n            keyOutput: letters\n          args:\n            renameColumns:\n              word: input-id\n            usecols:\n            - word\n            - letters\n```\n\nThe [`csvDataFrame`](/writing-a-virtual-experiment-interface#csvdataframe) property extraction method expects a CSV file which has the columns `input-id` and `${the property name}`. One of the requirements for using a ST4SD interface is that the property names start with a capital letter. One of the requirements of the `csvDataFrame` is that there should be a column with the same name as the property name that is being extracted. Another is that there should be a column called `input-id`.\n\nIn this example the components happen to produce key-output CSV files which contain a properly named column for the values of properties but instead of using the `input-id` column they use the column `word`. To account for this inconsistency, the developers of the workflow use the `renameColumns` argument of the `csvDataFrame` property extraction method. Via `renameColumns` they instruct `csvDataFrame` to treat the column `word` as if it were called `input-id`.\n\nThis means that you have to create a CSV file called `words.csv` and use it as an input for (via the `-i` arg) to the workflow.\n\nYou can find more information on this in the [creating an interface documentation](/writing-a-virtual-experiment-interface). Just keep in mind that this documentation was originally written with the FlowIR syntax in mind.\n\n## Differences between DSL 2.0 and FlowIR\n\nThere are some differences between DSL 2.0 and [FlowIR](/workflow-specification).\n\nIn the current version (0.3.x) of DSL 2.0:\n\n* we offer support for natural composition of Computational Graphs using Workflow and Component templates\n* the `signature` field replaces the `stage`, `name`, `references`, and `override` fields of the component specification in FlowIR\n* settings and inputs flow through parameters, we do not support global/stage environments or variables\n* the fields of components can contain `%(parameter)s` references as well as component `%(variable)s`\n* dependencies between components are defined by referencing the output of a producer component in one parameter of the consumer component - [DataReferences](/workflow-specification/#datareference) are reserved for referencing input files only\n    * the equivalent of a DataReference for Template instances is an OutputReference\n* data files and manifests\n* key outputs and interface\n\nDSL 2.0 will eventually contain a superset of the FlowIR features. However, the current beta version of DSL 2.0 does not support:\n\n* FlowIR platforms\n* application-dependencies\n    * however, you can use a manifest to implicitly define your application-dependencies\n","type":"Mdx","contentDigest":"1d1f9d9b38d14479e2c11a38cab403c6","owner":"gatsby-plugin-mdx","counter":282},"frontmatter":{"title":"DSL 2.0 Specification"},"exports":{},"rawBody":"---\ntitle: DSL 2.0 Specification\n---\n\n<!--\n\n  Copyright IBM Inc. All Rights Reserved.\n  SPDX-License-Identifier: Apache-2.0\n\n-->\n\n<PageDescription>\n\nUse this page to learn about the new Domain Specific Language (DSL 2.0) of ST4SD and how it works.\n\n</PageDescription>\n\n\n<InlineNotification kind=\"info\">\n\nHere, we are using DSL 2.0, if you need to understand the previous syntax check out the [FlowIR docs](/workflow-specification).\n\n</InlineNotification>\n\n<AnchorLinks>\n    <AnchorLink>Namespace</AnchorLink>\n    <AnchorLink>Entrypoint</AnchorLink>\n    <AnchorLink>Workflow</AnchorLink>\n    <AnchorLink>Component</AnchorLink>\n    <AnchorLink>Assigning values to parameters</AnchorLink>\n    <AnchorLink>OutputReference</AnchorLink>\n    <AnchorLink>Example</AnchorLink>\n    <AnchorLink>Key outputs</AnchorLink>\n    <AnchorLink>Interface</AnchorLink>\n    <AnchorLink>Differences between DSL 2.0 and FlowIR</AnchorLink>\n</AnchorLinks>\n\nDSL 2.0 is the new (and beta) way to define the computational graphs of ST4SD workflows.\n\n## Namespace\n\nIn DSL 2.0, a Computational Graph consists of Components which can be grouped under Workflow containers. \nIt also has an Entrypoint which points to the root node of the graph, which is an instance of a Component or Workflow template.\n\nA Namespace is simply a container for the Component, Workflow, and Entrypoint definitions which represent the Computational Graph of one ST4SD workflow. \n\nBelow is an example of a Namespace containing a single component that prints the message `Hello world` to the terminal.\n\n```yaml\nentrypoint:\n  entry-instance: print\n  execute:\n  - target: \"<entry-instance>\"\n    args:\n      message: Hello world\ncomponents:\n- signature:\n    name: print\n    parameters:\n      name: message\n  command:\n    executable: echo\n    arguments: \"%(message)s\"\n```\n\n## Entrypoint\n\nThe Optional Entrypoint serves a single purpose. Describe how to execute root Template instance of the Computational Graph.\n\nIts schema is:\n\n```yaml\n# This executes an instance of $template which is called \"<entry-instance>\"\nentry-instance: $template # name of a Component or Workflow template\nexecute: # an array with exactly 1 entry\n- target: <entry-instance> # which instance of a Template to execute.\n                           # In this scope there is only <entry-instance>\n  args:\n    $paramName: $value # one for each parameter of the template that\n                       # the \"target\" points to\n```\n\nThe `entry-instance` field receives the name of a Template and creates an instance of it called `<entry-instance>`.\nThe `execute` field then describes how to \"execute\" the `<entry-instance>` i.e. how to populate the arguments of the associated Template.\n\nIn `execute[].args` you:\n\n* **must** provide values for any parameters in the child `$template` which do not have default values\n* **may** override the value of the parameters in `$template` which have default values\n\nThe Template instance that the entrypoint points to can have special parameters which are data references to paths that are external to the workflow.\nThese parameters must be called `input.$filename` and they must not have default values in the signature of the Template definition.\nThe entrypoint **may** not explicitly override the values of said parameters, the runtime system will auto-generate them.\n\nConsider a scenario where the Template that the `<entry-instance>` step points to has a parameter called `input.my-input.db`. \nThe runtime will post-process the `entrypoint.execute[0].args` dictionary to include the following key-value pair:\n\n```yaml\ninput.my-input.db: \"input/my-input.db\"\n```\n\nIn [Assigning values to parameters](#assigning-values-to-parameters) we describe in more detail how to assign values to parameters of Template instances in general.\n\n\n## Workflow\n\nA Workflow is a Template that describes how to `execute` a number of Template instances called `steps`.\nIt has a `signature` that consists of a unique `name` and a `parameter` list. \nEach such step can consume the outputs of a sibling step, or the parameters of the parent Workflow.\n\nThe outputs of a workflow are its `steps`. The schema of Workflow is:\n\n```yaml\nsignature:\n  name: $Template # the name of this Workflow Template - must be unique\n  parameters:\n    - name: $paramName\n      # optional default value\n      default: $value # str, number, or dictionary of {str: str/number}\nsteps: # which steps to instantiate\n  $stepName: $Template # for example child: simulation-code\nexecute: # how to execute the steps - one for each entry of steps\n- target: <$stepName> # for example <child> or <child/grandchild>\n  args:\n    $paramName: $value # one for each parameter of the Template that\n                       # .target points to\n```\n\nIn [Assigning values to parameters](#assigning-values-to-parameters) we describe how to assign values to parameters of Template instances.\n\n## Component\n\nA Component describes how to `execute` a task.\nJust like a Workflow Template, it has a `signature` that consists of a `name` and a `parameter` list. \n\nThe outputs of a Component are the paths under its working directory. \n\nThe schema of a Component is:\n\n```yaml\nsignature:\n  name: $Template # the name of this Component Template - must be unique\n  parameters:\n    - name: $paramName\n      # optional default value\n      default: $value # str, number, or dictionary of {str: str/number}\n# All the FlowIR fields, except for stage, name, references, and override\ncommand:\n  executable: str\n  arguments: str\n  environment: (null, str)\nworkflowAttributes:\n  aggregate: bool\n  replicate: (int, null, str containing %(value-reference)s)\nresourceRequest:\n  numberProcesses: (int, str containing %(value-reference)s)\n  numberThreads: (int, str containing %(value-reference)s)\n  ranksPerNode: (int, str containing %(value-reference)s)\n  threadsPerCore: (int, str containing %(value-reference)s)\n  memory: (int (size in bytes), str containing %(value-reference)s or Mib/Kib bytes )\n  gpus: (int, str containing %(value-reference)s)\nresourceManager:\n  config:\n    backend: (name of backend e.g local, kubernetes, lsf, docker)\n    walltime: (in minutes, valid for \"kubernetes\" and \"lsf\" backends, float)\n  docker:\n    image: str\n    imagePullPolicy: (Optional) one of Always (default), Never, IfNotPresent\n  kubernetes:\n    image: str\n  lsf:\n    queue: str\nvariables:\n  <variable name:str>: <value: str, int, bool, float>\n```\n\nThe above fields are the same as those in the [Component section of the Workflow Specification in FlowIR](/workflow-specification/#component).\n\nFor more information, read our documentation on the [basic FlowIR component fields](/workflow-specification#description-of-basic-flowir-component-fields).\n\n## Assigning values to parameters\n\nBoth Component and Workflow templates are instantiated in the same way: \nby declaring them as a `step` and adding an entry to an `execute` block which assigns values to the Template's parameters.\n\nThe value of a parameter can be a number, string, or a key: value dictionary. \nThe body of a Template can reference its parameters like so `%(parameterName)s`.\n\nWhen assigning a value to the parameters of a template via the `execute[].args` dictionary\n\nIn `execute[].args` you:\n\n* **must** provide values for any parameters in the child `$template` which do not have default values\n* **may** override the value of the parameters in `$template` which have default values\n* **may** use `OutputReferences` to indicate dependencies to steps (definition follows this bullet list)\n* **may** use `%(parentParameter)s` to indicate a dependency to the value that the parent parameter has. In turn that can be a dependency to the output of a Template instance or an input file or it might just be a literal constant\n* **may** use a `$key: $value` dictionary to propagate a dictionary-type value. At the moment Template can only reference this kind of parameters to set the value of the `command.environment` field of Components\n* **may** use `%(input.$filename)s`to propagate an input file reference from a parent to a step. \n  - Eventually a step must apply a [DataReferences](/workflow-specification/#datareference) `:$method` to the parameter to indicates it wishes to consume the input file\n\n### Environments\n\nThe environment that components run in is defined in the `command.environment` field. If you don't define anything in this section ST4SD will create a default environment containing all the environment variables of the runtime system process.\n\nExample:\n\n```yaml\ncommand:\n  environment:\n    ENV-VAR1: value/for/env-var1\n    ENV-VAR2: value/for/env-var2\n    DEFAULTS: ENV-VAR3:ENV-VAR4\n```\n\nThe above defines an environment with 4 environment variables:\n\n- `ENV-VAR1` whose value is `value/for/env-var1`\n- `ENV-VAR2` whose value is `value/for/env-var2`\n- `ENV-VAR3` whose value is inherited from the environment variable `ENV-VAR3` of the process running the runtime system\n- `ENV-VAR4` whose value is inherited from the environment variable `ENV-VAR4` of the process running the runtime system\n\nIn the above example, we use the `DEFAULTS` directive to inherit the values for a list of environment variables from the environment variables of the runtime system process. The value of the special \"DEFAULTS\" key is a list of environment variable name separated with \":\".\n\nWant to find out more? Check out our [example](#example).\n\n### OutputReference\n\nThe format of an `OutputReference` is:\n\n```\n<$stepId>/$optionalPath:$optionalMethod\n```\n\n`$stepId` is a `/` separated array of `stepNames` starting from the scope of the current workflow. For example, the OutputReference `<one/child>/file.txt:ref` resolves to the absolute path of the file `file.txt` that the component `child` produces under the sibling step `one` which is an instance of a Workflow template. You can find more reference `methods` in our [DataReferences](/workflow-specification/#datareference) docs.\n\n\n\n\n# Example\n\nHere is a simple example which uses one Workflow and one Component template two run 2 tasks.\n\n- consume-input: prints the contents of an input file called `my-input.db`\n- consume-sibling: prints the text \"my sibling said\" followed by stdout of the sibling step `<consume-input>` \n\n```yaml\nentrypoint:\n  entry-instance: main\n  execute:\n  - target: <entry-instance>\nworkflows:\n- signature:\n    name: main\n    parameters:\n    # special variable with auto-populated value\n    - name: input.my-input.db\n  steps:\n    consume-input: echo\n    consume-sibling: echo\n  execute:\n    - target: <consume-input>\n      args:\n        # resolves to the contents of the file \n        # that input.my-input-d points to\n        message: \"%(input.my-input.db)s:output\"\n    - target: <consume-sibling>\n      args:\n        # resolves to the stdout of step consume-input\n        message: \"my sibling said <consume-input>:output\"\ncomponents:\n- signature:\n    name: echo\n    parameters:\n      - name: message\n  command:\n    executable: \"echo\"\n    arguments: \"%(message)s\"\n```\n\n\nTo try it out, store the above DSL in a file called `dsl-params.yaml` and run\n\n```\npip install \"st4sd-runtime-core[develop]>=2.5.1\"\n```\n\nwhich installs the command-line-tool elaunch.py, followed by:\n\n```bash\necho \"hello world\" >my-input.db\nelaunch.py -i my-input.db --failSafeDelays=no -l40 dsl-params.yaml\n```\n\n## Key outputs\n\nAll experiments produce files, but not all generated files are equally important. To this end ST4SD has the concept of key-outputs. These are files, and directories, that an experiment produces which the developers of the experiment consider important.\n\n\nHere is a an example of an experiment with a key-output:\n\n\n```yaml\nentrypoint:\n  entry-instance: hello\n  execute:\n  - target: <entry-instance>\n    args:\n      message: Hello world\n  output:\n    - name: greeting\n      data-in: <entry-instance>:output\n      description: just a friendly greeting\n\ncomponents:\n- signature:\n    name: hello\n    parameters:\n      - name: message\n  command:\n    executable: echo\n    arguments: \"%(message)s\"\n\n```\n\nThe `output` field in the `entrypoint` dictionary defines the key-outputs of this experiment:\n\n```yaml\nentrypoint:\n  # ... other fields ...\n  output:\n    - name: greeting\n      data-in: <entry-instance>:output\n```\n\nThis experiment has a single key-output called `greeting`. The data associated with this key-output is actually the `stdout` of the `<entry-instance>` step which is an instance of the `hello` component. As the experiment finishes producing this key-output the `$INSTANCE_DIR/output/output.json` file is updated to reflect the state of this experiment.\n\nHere's an how the `output.json` file will look like for the above key outputs:\n\n```json\n{\n    \"greeting\": {\n        \"creationtime\": \"1725374555.6836693\",\n        \"description\": \"just a friendly greeting\",\n        \"filename\": \"out.stdout\",\n        \"filepath\": \"stages/stage0/entry-instance/out.stdout\",\n        \"final\": \"yes\",\n        \"production\": \"yes\",\n        \"type\": \"\",\n        \"version\": \"1\"\n    }\n}\n```\n\nWhile the experiment is running, the runtime system asynchronously updates this file with metadata about the generated key-outputs of the experiment. In this example, there is just one key-output called `greeting`. For more information on key-outputs check out our [documentation](/workflow-specification#key-outputs).\n\nIf you are running experiments on the cloud and are instructing the runtime system to register them into the ST4SD datastore you may also use the ST4SD python API to [download](/running-workflows-on-openshift#retrieving-the-outputs-of-a-virtual-experiment-instance) the key-outputs of your experiment instances.\n\n## Interface\n\nKey outputs are not always immediately parseable without deep understanding of their format. To address this, ST4SD supports the **interface** feature. This feature allows workflow developers to extract measured properties and store them in a CSV file, making the data easier to consume.\n\n\nSome virtual experiments define interfaces which make it simpler for users to retrieve the input systems and measured properties from executions of that virtual experiment.\n\nThe `interface` of a virtual experiment defines:\n\n- The specification used to describe `input` systems it processes e.g. SMILEs for small molecules\n- Instructions to extract the `input` systems from input data\n- Instructions to extract the values of `properties` that the virtual experiment computes\n\nOnce a virtual experiment has an `interface`  ST4SD can return a `pandas.DataFrame`  containing the properties calculated by instances of the virtual experiment, as well as the ids of the `input` systems that an instance processed. This functionality is provided via the `st4sd-datastore` API and the `st4sd-runtime-service` API. See [using a virtual experiment interface](/using-a-virtual-experiment-interface) for further information.\n\n\nIn this example we will work with a virtual experiment which:\n1. extracts the IDs of its input systems\n2. has 2 key-outputs that correspond to 2 measured properties of the interface\n3. uses builtin hooks to extract the measured properties from the key-outputs\n\nThe DSL of the experiment is :\n\n```yaml\nentrypoint:\n  interface:\n    description: Counts vowels in words\n    inputSpec:\n      namingScheme: words\n      inputExtractionMethod:\n        csvColumn:\n          source:\n            path: input/words.csv\n          args:\n            column: word\n    propertiesSpec:\n    - name: Vowels\n      propertyExtractionMethod:\n        csvDataFrame:\n          source:\n            keyOutput: vowels\n          args:\n            renameColumns:\n              word: input-id\n            usecols:\n            - word\n            - vowels\n    - name: Letters\n      propertyExtractionMethod:\n        csvDataFrame:\n          source:\n            keyOutput: letters\n          args:\n            renameColumns:\n              word: input-id\n            usecols:\n            - word\n            - letters\n  output:\n    - name: vowels\n      data-in: <entry-instance/count-vowels>/vowels.csv:ref\n    - name: letters\n      data-in: <entry-instance/count-letters>/letters.csv:ref\n\n  entry-instance: main\n  execute:\n    - target: <entry-instance>\n      args:\n        words_file: input/words.csv:ref\n\nworkflows:\n  - signature:\n      name: main\n      parameters:\n        - name: words_file\n    steps:\n      count-vowels: count-vowels\n      count-letters: count-letters\n    execute:\n      - target: <count-vowels>\n        args:\n          words: \"%(words_file)s\"\n      - target: <count-letters>\n        args:\n          words: \"%(words_file)s\"\n\ncomponents:\n- signature:\n    name: count-vowels\n    parameters:\n    - name: words\n  command:\n    executable: bin/count_vowels.py\n    arguments: \"%(words)s\"\n\n- signature:\n    name: count-letters\n    parameters:\n      - name: words\n  command:\n    executable: bin/count_letters.py\n    arguments: \"%(words)s\"\n```\n\n\nThe interface contains a human readable description of the experiment under `entrypoint.interface.description`.\n\n```yaml\nentrypoint:\n  interface:\n    description: Counts vowels in words\n```\n\nThen, in `entrypoint.interface.inputspec` it uses the builtin input extraction method `csvColumn` to extract the ids of the systems it processes:\n\n```yaml\nentrypoint:\n  interface:\n    inputSpec:\n      namingScheme: words\n      inputExtractionMethod:\n        csvColumn:\n          source:\n            path: input/words.csv\n          args:\n            column: word\n```\n\nIt instructs the method to read the CSV file `input/words.csv` (i.e. the input file) and treat every row of the CSV as one input system whose identifier lies in the column `word`.\n\nFollowing that, it uses the builtin property extraction method `csvDataFrame` twice to measure its 2 properties `Vowels` and `Letters` from the key-outputs `vowels` and `letters` respectively.\n\n```yaml\nentrypoint:\n  interface:\n    propertiesSpec:\n    - name: Vowels\n      propertyExtractionMethod:\n        csvDataFrame:\n          source:\n            keyOutput: vowels\n          args:\n            renameColumns:\n              word: input-id\n            usecols:\n            - word\n            - vowels\n    - name: Letters\n      propertyExtractionMethod:\n        csvDataFrame:\n          source:\n            keyOutput: letters\n          args:\n            renameColumns:\n              word: input-id\n            usecols:\n            - word\n            - letters\n```\n\nThe [`csvDataFrame`](/writing-a-virtual-experiment-interface#csvdataframe) property extraction method expects a CSV file which has the columns `input-id` and `${the property name}`. One of the requirements for using a ST4SD interface is that the property names start with a capital letter. One of the requirements of the `csvDataFrame` is that there should be a column with the same name as the property name that is being extracted. Another is that there should be a column called `input-id`.\n\nIn this example the components happen to produce key-output CSV files which contain a properly named column for the values of properties but instead of using the `input-id` column they use the column `word`. To account for this inconsistency, the developers of the workflow use the `renameColumns` argument of the `csvDataFrame` property extraction method. Via `renameColumns` they instruct `csvDataFrame` to treat the column `word` as if it were called `input-id`.\n\nThis means that you have to create a CSV file called `words.csv` and use it as an input for (via the `-i` arg) to the workflow.\n\nYou can find more information on this in the [creating an interface documentation](/writing-a-virtual-experiment-interface). Just keep in mind that this documentation was originally written with the FlowIR syntax in mind.\n\n## Differences between DSL 2.0 and FlowIR\n\nThere are some differences between DSL 2.0 and [FlowIR](/workflow-specification).\n\nIn the current version (0.3.x) of DSL 2.0:\n\n* we offer support for natural composition of Computational Graphs using Workflow and Component templates\n* the `signature` field replaces the `stage`, `name`, `references`, and `override` fields of the component specification in FlowIR\n* settings and inputs flow through parameters, we do not support global/stage environments or variables\n* the fields of components can contain `%(parameter)s` references as well as component `%(variable)s`\n* dependencies between components are defined by referencing the output of a producer component in one parameter of the consumer component - [DataReferences](/workflow-specification/#datareference) are reserved for referencing input files only\n    * the equivalent of a DataReference for Template instances is an OutputReference\n* data files and manifests\n* key outputs and interface\n\nDSL 2.0 will eventually contain a superset of the FlowIR features. However, the current beta version of DSL 2.0 does not support:\n\n* FlowIR platforms\n* application-dependencies\n    * however, you can use a manifest to implicitly define your application-dependencies\n","fileAbsolutePath":"/home/travis/build/st4sd/overview/src/pages/workflow-specification-dsl.mdx"}}},"staticQueryHashes":["1364590287","137577622","2102389209","2456312558","2746626797","3018647132","3037994772","768070550"]}