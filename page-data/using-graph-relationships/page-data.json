{"componentChunkName":"component---src-pages-using-graph-relationships-mdx","path":"/using-graph-relationships/","result":{"pageContext":{"frontmatter":{"title":"Using graph relationships"},"relativePagePath":"/using-graph-relationships.mdx","titleType":"page","MdxNode":{"id":"e42ca99c-dcbe-5998-83e2-9bdaa4028c75","children":[],"parent":"700ad0f8-4222-5361-8344-bbe27116086a","internal":{"content":"---\ntitle: Using graph relationships\n---\n\n<!--\n\n  Copyright IBM Inc. All Rights Reserved.\n  SPDX-License-Identifier: Apache-2.0\n\n-->\n\n<PageDescription>\n\nUse this page to learn how to use define relationships between virtual experiment graphs.\nReaders should be familiar with the [FlowIR](/workflow-specification) specification of components.\n</PageDescription>\n\n<AnchorLinks>\n  <AnchorLink>What is a relationship?</AnchorLink>\n  <AnchorLink>Structure of a relationship</AnchorLink>\n  <AnchorLink>Pushing a relationship to the runtime</AnchorLink>\n  <AnchorLink>Automatically synthesize new parameterised packages</AnchorLink>\n</AnchorLinks>\n\n## What is a relationship?\n\nA core concept in ST4SD is the virtual experiment. A virtual experiment defines its execution logic in the form of a computational graph. This enables ST4SD to apply graph operations on the graphs of virtual experiments.\n\nFor example the runtime support of ST4SD for surrogate models performs a wide range of graph operations on the graphs of virtual experiments. It extracts sub-graphs from one or more virtual experiments, modifies them. Finally, it uses the transformed sub-graphs to update the graphs of different virtual experiment and even generate novel virtual experiments.\n\n\n## Structure of a relationship\n\nST4SD currently features one type of relationship which we term the `transformation` relationship.\n\nA `transformation` explains how to replace the `$outputGraph` nodes in a `target` graph with `transform($inputGraph)` nodes from a `source` graph. Where `transform()` produces a graph that produces the same outputs as `$outputGraph`.\n\nTo achieve this, the transformation relationship defines how to:\n1.  Map each of `$inputGraph` to a parameter of `$outputGraph` (or a default value evaluated in the scope of `target`)\n2.  Map each result of `$outputGraph` to a result of `$inputGraph` (or a default value evaluated in the scope of `source`).\n\nParameters of the `inputGraph` are `variables` and [`DataReferences`](/workflow-specification#datareference) that `$inputGraph` references which are not produced by nodes in the `$inputGraph` subset of the source graph.\nThe results of the `$outputGraph` are `DataReferences` which leftover nodes in the `target` graph consume which point to `$outputGraph` nodes.\n\nNotice that parameters and results can be either DataReferences, variables, or strings which contain references to 0 or more variables. This means that the schema enables you to replace a DataReference in one graph with a string containing 0 or more references to variables of the other graph. In some cases this is a valid transformation action, but this is not the general case.\n\nTo this end, when you submit/update a transformation to the runtime service, the service will run tests to ensure that transformation can produce a valid experiment.\nHere are the rules that parameter and result mappings must follow:\n\n1. It is a **valid** operation to substitute a variable in one of the graphs with the value of another variable, or a `value` that contains 0 or more references to variables in the other graph.\n2. It is a **valid** operation to substitute a DataReference `A` in one of the graphs with a DataReference `B` in the other graph provided that `B` is valid in the scope of the resulting experiment graph.\n3. It is an **invalid** operation to substitute a variable in one of the graphs which is used in a place other than the command-line arguments of components with a DataReference\n\nThe `schema` of the relationship transformation (in YAML) is:\n\n```yaml\nrelationship:\n  identifier: name of relationship\n  transform: # there is currently only 1 type of relationship\n    inputGraph: # required\n      components: # required\n      - component identifiers to include\n      # must set exactly 1 of identifier or source\n      identifier: |\n        the string identifier of an existing ParameterisedPackage\n        This syntax sugar field is mutually exclusive with \"source\" field below\n        When set, the runtime sets source to base.packages[0].source\n        of the existing ParameterisedPackage\n      source: # same schema as ParameterisedPackage.base.packages[idx].source\n        git:\n          location:\n            url: https://url/to/clone\n            # one of branch, tag, or commit\n            branch: branch mane (mutually exclusive with tag and commit)\n            tag: branch mane (mutually exclusive with branch and commit)\n            commit: branch mane (mutually exclusive with branch and tag)\n        dataset:\n          location: dataset name\n    outputGraph: identical to relationship.transform.inputGraph (required)\n      components:\n      - component identifiers to exclude from outputGraph\n    relationship: # required\n      inferParameters: true/false (default is true)\n      inferResults: true/false (default is true)\n      graphParameters: # Optional\n      - inputGraphParameter:\n          name: parameter name\n        outputGraphParameter:\n          # name and value are mutually exclusive\n          name: parameter name\n          value: a string which may contain references to variables\n            in the context of the OutputGraph\n      graphResults: # Optional\n      - inputGraphResult:\n          # name and value are mutually exclusive\n          name: parameter\n          value: a string which may contain references to variables\n            in the context of the InputGraph\n        outputGraphResult:\n          name: parameter\n\n```\n\n\n<InlineNotification kind=\"info\">\nThe runtime inspects the graphs and how they are used to infer obvious mappings between parameters (if inferParameters is true) and results (if inferResults is true).\n</InlineNotification>\n\nThe runtime validates the transformation relationships by testing that:\n\n1. All inputGraph parameters have a relationship to an outputGraph parameter\n1. All outputGraph results have a relationship to an inputGraph result\n\n\n### Pushing a relationship to the runtime\nYou can submit a `relationship` to the ST4SD runtime-service API using the method `experiment.service.db.ExperimentRestAPI.api_relationship_push()`.\n\n\n<InlineNotification kind=\"info\">\nThe schema above is in YAML format. If you are using python (i.e. an instance of experiment.service.db.ExperimentRestAPI) you should either create an equivalent python dictionary OR a python string that contains the yaml definition and then convert the string into a dictionary using \"yaml.loads(the_string)\".\n</InlineNotification>\n\n#### Example: push a relationship\n\n\n```python\nfrom __future__ import typing\nimport json\ndef relationship_push(api: experiment.service.db.ExperimentRestAPI):\n    \"\"\"Creates a Transformation relationship between 2 parameterised\n    packages from the ST4SD global registry\n\n    Arguments:\n      api: An instance of ExperimentRestAPI that has connected to your\n           private ST4SD registry\n\n    Notes:\n\n      The method expects that you have already imported 2 parameterised\n      packages from the ST4SD global registry into your private registry.\n      The parameterised packages are: ::\n\n        1. configuration-generator-ani (contains the inputGraph)\n        2. band-gap-dft-gamess-us (contains the outputGraph)\n    \"\"\"\n\n    relationship = {\n      \"identifier\": \"optimizedconfiguration-to-smilesinput\",\n      \"transform\": {\n        \"inputGraph\": {\n          \"identifier\": \"configuration-generator-ani:latest\",\n          \"components\": [\n            \"stage0.GenerateOptimizedConfiguration\"\n          ]\n        },\n        \"outputGraph\": {\n          \"identifier\": \"band-gap-dft-gamess-us:latest\",\n          \"components\": [\n            \"stage0.SMILESToGAMESSInput\"\n          ]\n        }\n      }\n    }\n\n    relationship_fleshed_out = api.api_relationship_push(relationship)\n\n    # The runtime system infers mappings between parameters and results\n    print(json.dumps(relationship_fleshed_out, indent=2)\n```\n\n### Automatically synthesize new parameterised packages\n\nYou can use a `transformation` relationship to automatically synthesize a novel virtual parameterised virtual experiment package like so:\n\n\n<Row>\n  <Column colMd={8} colLg={8} noGutterSm>\n\n![Use a transformation relationship to synthesize a new parameterised package](../assets/images/graph-relationships/transformation-synthesize.png)\n\n  </Column>\n</Row>\n\nA user can trigger the runtime to synthesize a new parameterised package by submitting a `synthesis-from-transformation-relationship` payload to the runtime service using the method `experiment.service.db.ExperimentRestAPI.api_relationship_synthesize()`.\n\nThe structure (in `YAML`) of the payload is:\n\n```yaml\nparameterisation:\n  presets:  # optional\n    # Fields defined here *cannot* be overridden by `executionOptions`.\n    # All fields are optional\n    variables: #A list of preset values for variables in the virtual experiment\n    - name: $name of variable\n      value: $variableValue\n    data:\n      - name: name of a file in the \"data\" directory\n        value: contents of file - utf8 string (not suitable for binary files)\n    runtime:\n      args:\n      - array of `elaunch.py` command line strings\n    platform:  #Value for the experiment platform.\n  executionOptions: # optional\n    # users may override values within constraints that workflow developers set\n    variables:\n    # Variables that the developer allows the user to override.\n    # These CANNOT appear in presets.variables\n    - name: $variable name\n      valueFrom: #Optional: An array of possible values for the variable\n      # If a user does set a value for the variable the 1st entry is used\n      # If valueFrom is not given then user can set any value for the variable.\n      # if they do not set any value then the variable\n      # receives the value that the workflow definition contains in\n      # the platform definition\n      - value: value of variable\n    data: #A list of data files whose contents the user can set.\n    - name: filename under `data` directory, the file must already exist\n    runtime: # Arguments to pass to `elaunch.py`\n             # (cannot include -i -a -d --instanceName)\n      args:\n      - array of elaunch.py command line strings\n    platform: #Default for experiment platform or choice.\n              # Cannot be specified here if in `presets`\n    - an array of platform names. # If the user does not specifying one on start\n                                  # then the 1st entry is used. If no platform\n                                  # is specified the `default` platform is used\n\n\n```\n\n<InlineNotification kind=\"info\">\nThe \"parameterisation\" field is identical to the \"parameterisation\" field of parameterised packages. You can find more details about it in our [parameterised package documentation](/creating-a-parameterised-package#the-parameterisation-section).\n</InlineNotification>\n\n\n<InlineNotification kind=\"info\">\nThe schema above is in YAML format. If you are using python (i.e. an instance of experiment.service.db.ExperimentRestAPI) you should either create an equivalent python dictionary OR a python string that contains the yaml definition and then convert the string into a dictionary using \"yaml.loads(the_string)\".\n</InlineNotification>\n\nSide effects of synthesis step:\n\n1. The runtime service will create a novel parameterised package on the registry.\n1. The new parameterised package:\n   1. will contain all components from the virtual experiment that contains `outputGraph` except for those in the `outputGraph`. The runtime system will substitute those for the components of the transformed `inputGraph`.\n   1. will have the parameterisation options specified in the `parameterisation` field of the schema above.\n   1. inherits the [`interface`](/using-a-virtual-experiment-interface) of the virtual experiment that contains the `outputGraph`\n\n\n### Example: use a transformation relationship to auto-generate a new parameterised package\n\n```python\nfrom __future__ import typing\nimport json\ndef relationship_synthesize(api: experiment.service.db.ExperimentRestAPI):\n    \"\"\"Uses a transformation relationship to synthesize a new parameterised\n    package.\n\n    Arguments:\n      api: An instance of ExperimentRestAPI that has connected to your\n           private ST4SD registry\n\n    Notes:\n\n      The method expects that you have already created the transformation\n      relationship \"optimizedconfiguration-to-smilesinput\" in your\n      ST4SD registry.\n    \"\"\"\n\n    config = {\n        \"parameterisation\": {\n            \"presets\": {\n                \"platform\": \"openshift\",\n            },\n            \"executionOptions\": {\n                \"runtime\": {\n                    \"args\": [\n                        \"--registerWorkflow=yes\"\n                    ]\n                },\n                \"variables\": [\n                    {\n                        \"name\": \"n_conformers\"\n                    },\n                    {\n                        \"name\": \"max_iterations\"\n                    }\n                ]\n            }\n        }\n    }\n\n    synthetic_pvep = api.api_relationship_synthesize(\n        # relationship identifier\n        \"optimizedconfiguration-to-smilesinput\",\n        config,\n        # name of new PVEP\n        \"synthetic\")\n    print(json.dumps(synthetic_pvep, indent=2))\n```\n","type":"Mdx","contentDigest":"9c5dba198a7ef60e38424525ac1463f5","owner":"gatsby-plugin-mdx","counter":244},"frontmatter":{"title":"Using graph relationships"},"exports":{},"rawBody":"---\ntitle: Using graph relationships\n---\n\n<!--\n\n  Copyright IBM Inc. All Rights Reserved.\n  SPDX-License-Identifier: Apache-2.0\n\n-->\n\n<PageDescription>\n\nUse this page to learn how to use define relationships between virtual experiment graphs.\nReaders should be familiar with the [FlowIR](/workflow-specification) specification of components.\n</PageDescription>\n\n<AnchorLinks>\n  <AnchorLink>What is a relationship?</AnchorLink>\n  <AnchorLink>Structure of a relationship</AnchorLink>\n  <AnchorLink>Pushing a relationship to the runtime</AnchorLink>\n  <AnchorLink>Automatically synthesize new parameterised packages</AnchorLink>\n</AnchorLinks>\n\n## What is a relationship?\n\nA core concept in ST4SD is the virtual experiment. A virtual experiment defines its execution logic in the form of a computational graph. This enables ST4SD to apply graph operations on the graphs of virtual experiments.\n\nFor example the runtime support of ST4SD for surrogate models performs a wide range of graph operations on the graphs of virtual experiments. It extracts sub-graphs from one or more virtual experiments, modifies them. Finally, it uses the transformed sub-graphs to update the graphs of different virtual experiment and even generate novel virtual experiments.\n\n\n## Structure of a relationship\n\nST4SD currently features one type of relationship which we term the `transformation` relationship.\n\nA `transformation` explains how to replace the `$outputGraph` nodes in a `target` graph with `transform($inputGraph)` nodes from a `source` graph. Where `transform()` produces a graph that produces the same outputs as `$outputGraph`.\n\nTo achieve this, the transformation relationship defines how to:\n1.  Map each of `$inputGraph` to a parameter of `$outputGraph` (or a default value evaluated in the scope of `target`)\n2.  Map each result of `$outputGraph` to a result of `$inputGraph` (or a default value evaluated in the scope of `source`).\n\nParameters of the `inputGraph` are `variables` and [`DataReferences`](/workflow-specification#datareference) that `$inputGraph` references which are not produced by nodes in the `$inputGraph` subset of the source graph.\nThe results of the `$outputGraph` are `DataReferences` which leftover nodes in the `target` graph consume which point to `$outputGraph` nodes.\n\nNotice that parameters and results can be either DataReferences, variables, or strings which contain references to 0 or more variables. This means that the schema enables you to replace a DataReference in one graph with a string containing 0 or more references to variables of the other graph. In some cases this is a valid transformation action, but this is not the general case.\n\nTo this end, when you submit/update a transformation to the runtime service, the service will run tests to ensure that transformation can produce a valid experiment.\nHere are the rules that parameter and result mappings must follow:\n\n1. It is a **valid** operation to substitute a variable in one of the graphs with the value of another variable, or a `value` that contains 0 or more references to variables in the other graph.\n2. It is a **valid** operation to substitute a DataReference `A` in one of the graphs with a DataReference `B` in the other graph provided that `B` is valid in the scope of the resulting experiment graph.\n3. It is an **invalid** operation to substitute a variable in one of the graphs which is used in a place other than the command-line arguments of components with a DataReference\n\nThe `schema` of the relationship transformation (in YAML) is:\n\n```yaml\nrelationship:\n  identifier: name of relationship\n  transform: # there is currently only 1 type of relationship\n    inputGraph: # required\n      components: # required\n      - component identifiers to include\n      # must set exactly 1 of identifier or source\n      identifier: |\n        the string identifier of an existing ParameterisedPackage\n        This syntax sugar field is mutually exclusive with \"source\" field below\n        When set, the runtime sets source to base.packages[0].source\n        of the existing ParameterisedPackage\n      source: # same schema as ParameterisedPackage.base.packages[idx].source\n        git:\n          location:\n            url: https://url/to/clone\n            # one of branch, tag, or commit\n            branch: branch mane (mutually exclusive with tag and commit)\n            tag: branch mane (mutually exclusive with branch and commit)\n            commit: branch mane (mutually exclusive with branch and tag)\n        dataset:\n          location: dataset name\n    outputGraph: identical to relationship.transform.inputGraph (required)\n      components:\n      - component identifiers to exclude from outputGraph\n    relationship: # required\n      inferParameters: true/false (default is true)\n      inferResults: true/false (default is true)\n      graphParameters: # Optional\n      - inputGraphParameter:\n          name: parameter name\n        outputGraphParameter:\n          # name and value are mutually exclusive\n          name: parameter name\n          value: a string which may contain references to variables\n            in the context of the OutputGraph\n      graphResults: # Optional\n      - inputGraphResult:\n          # name and value are mutually exclusive\n          name: parameter\n          value: a string which may contain references to variables\n            in the context of the InputGraph\n        outputGraphResult:\n          name: parameter\n\n```\n\n\n<InlineNotification kind=\"info\">\nThe runtime inspects the graphs and how they are used to infer obvious mappings between parameters (if inferParameters is true) and results (if inferResults is true).\n</InlineNotification>\n\nThe runtime validates the transformation relationships by testing that:\n\n1. All inputGraph parameters have a relationship to an outputGraph parameter\n1. All outputGraph results have a relationship to an inputGraph result\n\n\n### Pushing a relationship to the runtime\nYou can submit a `relationship` to the ST4SD runtime-service API using the method `experiment.service.db.ExperimentRestAPI.api_relationship_push()`.\n\n\n<InlineNotification kind=\"info\">\nThe schema above is in YAML format. If you are using python (i.e. an instance of experiment.service.db.ExperimentRestAPI) you should either create an equivalent python dictionary OR a python string that contains the yaml definition and then convert the string into a dictionary using \"yaml.loads(the_string)\".\n</InlineNotification>\n\n#### Example: push a relationship\n\n\n```python\nfrom __future__ import typing\nimport json\ndef relationship_push(api: experiment.service.db.ExperimentRestAPI):\n    \"\"\"Creates a Transformation relationship between 2 parameterised\n    packages from the ST4SD global registry\n\n    Arguments:\n      api: An instance of ExperimentRestAPI that has connected to your\n           private ST4SD registry\n\n    Notes:\n\n      The method expects that you have already imported 2 parameterised\n      packages from the ST4SD global registry into your private registry.\n      The parameterised packages are: ::\n\n        1. configuration-generator-ani (contains the inputGraph)\n        2. band-gap-dft-gamess-us (contains the outputGraph)\n    \"\"\"\n\n    relationship = {\n      \"identifier\": \"optimizedconfiguration-to-smilesinput\",\n      \"transform\": {\n        \"inputGraph\": {\n          \"identifier\": \"configuration-generator-ani:latest\",\n          \"components\": [\n            \"stage0.GenerateOptimizedConfiguration\"\n          ]\n        },\n        \"outputGraph\": {\n          \"identifier\": \"band-gap-dft-gamess-us:latest\",\n          \"components\": [\n            \"stage0.SMILESToGAMESSInput\"\n          ]\n        }\n      }\n    }\n\n    relationship_fleshed_out = api.api_relationship_push(relationship)\n\n    # The runtime system infers mappings between parameters and results\n    print(json.dumps(relationship_fleshed_out, indent=2)\n```\n\n### Automatically synthesize new parameterised packages\n\nYou can use a `transformation` relationship to automatically synthesize a novel virtual parameterised virtual experiment package like so:\n\n\n<Row>\n  <Column colMd={8} colLg={8} noGutterSm>\n\n![Use a transformation relationship to synthesize a new parameterised package](../assets/images/graph-relationships/transformation-synthesize.png)\n\n  </Column>\n</Row>\n\nA user can trigger the runtime to synthesize a new parameterised package by submitting a `synthesis-from-transformation-relationship` payload to the runtime service using the method `experiment.service.db.ExperimentRestAPI.api_relationship_synthesize()`.\n\nThe structure (in `YAML`) of the payload is:\n\n```yaml\nparameterisation:\n  presets:  # optional\n    # Fields defined here *cannot* be overridden by `executionOptions`.\n    # All fields are optional\n    variables: #A list of preset values for variables in the virtual experiment\n    - name: $name of variable\n      value: $variableValue\n    data:\n      - name: name of a file in the \"data\" directory\n        value: contents of file - utf8 string (not suitable for binary files)\n    runtime:\n      args:\n      - array of `elaunch.py` command line strings\n    platform:  #Value for the experiment platform.\n  executionOptions: # optional\n    # users may override values within constraints that workflow developers set\n    variables:\n    # Variables that the developer allows the user to override.\n    # These CANNOT appear in presets.variables\n    - name: $variable name\n      valueFrom: #Optional: An array of possible values for the variable\n      # If a user does set a value for the variable the 1st entry is used\n      # If valueFrom is not given then user can set any value for the variable.\n      # if they do not set any value then the variable\n      # receives the value that the workflow definition contains in\n      # the platform definition\n      - value: value of variable\n    data: #A list of data files whose contents the user can set.\n    - name: filename under `data` directory, the file must already exist\n    runtime: # Arguments to pass to `elaunch.py`\n             # (cannot include -i -a -d --instanceName)\n      args:\n      - array of elaunch.py command line strings\n    platform: #Default for experiment platform or choice.\n              # Cannot be specified here if in `presets`\n    - an array of platform names. # If the user does not specifying one on start\n                                  # then the 1st entry is used. If no platform\n                                  # is specified the `default` platform is used\n\n\n```\n\n<InlineNotification kind=\"info\">\nThe \"parameterisation\" field is identical to the \"parameterisation\" field of parameterised packages. You can find more details about it in our [parameterised package documentation](/creating-a-parameterised-package#the-parameterisation-section).\n</InlineNotification>\n\n\n<InlineNotification kind=\"info\">\nThe schema above is in YAML format. If you are using python (i.e. an instance of experiment.service.db.ExperimentRestAPI) you should either create an equivalent python dictionary OR a python string that contains the yaml definition and then convert the string into a dictionary using \"yaml.loads(the_string)\".\n</InlineNotification>\n\nSide effects of synthesis step:\n\n1. The runtime service will create a novel parameterised package on the registry.\n1. The new parameterised package:\n   1. will contain all components from the virtual experiment that contains `outputGraph` except for those in the `outputGraph`. The runtime system will substitute those for the components of the transformed `inputGraph`.\n   1. will have the parameterisation options specified in the `parameterisation` field of the schema above.\n   1. inherits the [`interface`](/using-a-virtual-experiment-interface) of the virtual experiment that contains the `outputGraph`\n\n\n### Example: use a transformation relationship to auto-generate a new parameterised package\n\n```python\nfrom __future__ import typing\nimport json\ndef relationship_synthesize(api: experiment.service.db.ExperimentRestAPI):\n    \"\"\"Uses a transformation relationship to synthesize a new parameterised\n    package.\n\n    Arguments:\n      api: An instance of ExperimentRestAPI that has connected to your\n           private ST4SD registry\n\n    Notes:\n\n      The method expects that you have already created the transformation\n      relationship \"optimizedconfiguration-to-smilesinput\" in your\n      ST4SD registry.\n    \"\"\"\n\n    config = {\n        \"parameterisation\": {\n            \"presets\": {\n                \"platform\": \"openshift\",\n            },\n            \"executionOptions\": {\n                \"runtime\": {\n                    \"args\": [\n                        \"--registerWorkflow=yes\"\n                    ]\n                },\n                \"variables\": [\n                    {\n                        \"name\": \"n_conformers\"\n                    },\n                    {\n                        \"name\": \"max_iterations\"\n                    }\n                ]\n            }\n        }\n    }\n\n    synthetic_pvep = api.api_relationship_synthesize(\n        # relationship identifier\n        \"optimizedconfiguration-to-smilesinput\",\n        config,\n        # name of new PVEP\n        \"synthetic\")\n    print(json.dumps(synthetic_pvep, indent=2))\n```\n","fileAbsolutePath":"/home/travis/build/st4sd/overview/src/pages/using-graph-relationships.mdx"}}},"staticQueryHashes":["1364590287","137577622","2102389209","2456312558","2746626797","3018647132","3037994772","768070550"]}