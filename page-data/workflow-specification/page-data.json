{"componentChunkName":"component---src-pages-workflow-specification-mdx","path":"/workflow-specification/","result":{"pageContext":{"frontmatter":{"title":"Workflow Specification"},"relativePagePath":"/workflow-specification.mdx","titleType":"page","MdxNode":{"id":"13b6ad56-e045-5ce0-b64a-a83ee71b2748","children":[],"parent":"812e315f-546a-5eea-8f54-da631f5e6e94","internal":{"content":"---\ntitle: Workflow Specification\n---\n\n<!--\n\n  Copyright IBM Inc. All Rights Reserved.\n  SPDX-License-Identifier: Apache-2.0\n\n-->\n\n<PageDescription>\n\nUse this page to learn what FlowIR elements are there and how they work.\n\n</PageDescription>\n\n<AnchorLinks>\n  <AnchorLink>Component</AnchorLink>\n  <AnchorLink>DataReference</AnchorLink>\n  <AnchorLink>Environments</AnchorLink>\n  <AnchorLink>Variables</AnchorLink>\n  <AnchorLink>Blueprints</AnchorLink>\n  <AnchorLink>Platforms</AnchorLink>\n  <AnchorLink>FlowIR Scopes</AnchorLink>\n  <AnchorLink>FlowIR options/variable inheritance sequence</AnchorLink>\n  <AnchorLink>Key-outputs</AnchorLink>\n  <AnchorLink>Interface and Properties</AnchorLink>\n</AnchorLinks>\n\n## Component\n\nThe component element describes a step in the workflow. The definition for a component is (some fields omitted):\n\n```yaml\nstage: integer greater or equal to 0 (optional - defaults to 0)\nname: the name of the component (must be unique in the same stage)\ncommand:\n  executable: str\n  arguments: str\n  environment: (null, str)\nreferences:\n- <reference:str>\nworkflowAttributes:\n  aggregate: bool\n  replicate: (int, null, str containing %(variable-reference)s or array access)\nresourceRequest:\n  numberProcesses: (int, str containing %(variable-reference)s or array access)\n  numberThreads: (int, str containing %(variable-reference)s or array access)\n  ranksPerNode: (int, str containing %(variable-reference)s or array access)\n  threadsPerCore: (int, str containing %(variable-reference)s or array access)\n  memory: (int (size in bytes), str containing %(variable-reference)s or array access or Mib/Kib bytes )\nresourceManager:\n  config:\n    backend: (name of backend e.g \"local\", \"kubernetes\", \"lsf\", etc:str)\n  kubernetes:\n    image: str\n    image-pull-secret: (null, str)\n    namespace: (null, str)\n    host: (null, str)\nvariables:\n  s<variable name:str>: <value: str, int, bool, float>\n```\n\n### Override\n\nComponents have an `override` key that allows overriding their definition based on the active platform. The definition of the override field is:\n\n```yaml\noverride:\n  <platform name:str>:\n    <component-field> #Any top-level field (with the sub-keys to be overriden) except name, stage  command and reference\n```\n\nThe main reason to do this is change `variables` ,`workflowAttributes` `resourceManager` or `resourceRequest`, based on e.g. GPU or CPU deployment (see [platform][#platforms]).\n\nOnly the key/values specified are changed or added. Existing key/values that aren't specified remain with their base values. For example:\n\n```yaml\n...\nresourceRequest:\n  numberThreads: 16\n  threadsPerCore: 1\n\tmemory: 100 MBi\noverride:\n   bigmem:\n     resourceRequest:\n       memory: 1GBi\n```\n\nIn this case on platform `bigmem` this component would still ask for 16 cores but with an increased memory request.  \n\n### Description of basic FlowIR component fields\n\n- stage: integer greater or equal to 0 (optional - defaults to 0)\n- name: the name of the component (must be unique in the same stage)\n- command:\n  - executable: path to executable. It can be absolute, relative to the instance directory by prefixing the path with `bin/` or `<application>/`. It can also be just the name of a binary. If the path is not absolute the `st4sd-runtime` will look for the executable in the folders specified under `$PATH`.\n  - arguments: arguments to binary\n  - environment: Name of the `environment` to use. The definition will be searched in the top level `environments` field of FlowIR.\n- references: Each string in this list is a string representation of a [DataReference](#datareference) to either a reference to a file, a folder, or a component. References to components and files produced by a component (i.e. under the working directory of a component) indicate a data dependency which the `st4sd-runtime` respects when scheduling the tasks for components. There are several `reference methods`, but these are the most commonly used:\n  - `:output`: the `st4sd-runtime` will replace `<component name>:output` references with the `stdout` output of the referenced component\n  - `:ref`: the `st4sd-runtime` will replace `<component name or file>:ref` references with the absolute path to the component or file on the filesystem.\n  - `:copy`: the `st4sd-runtime` will copy the file referenced by this DataReference into the working directory of the component which includes this reference. This DataReference method cannot be part of the `command.arguments` field.\n- workflowAttributes:\n  - replicate: If set to a positive number `N` the `st4sd-runtime` will replicate this component and its downstream tree `N` times (see `aggregate` below before you use this option).\n  - aggregate: If this option is set to `True` and the component belongs in the downstream sub-tree of a `replicate` component the `st4sd-runtime` will stop replicating just before the `aggregate` component. Each reference of the `aggregate` component to the `replicate` component will be expanded to `N` references (one for each upstream replicated component).\n- resourceRequest: provides hints to the backend about the resource requirements of this component tasks\n  - numberProcesses\n  - numberThreads\n  - ranksPerNode\n  - threadsPerCore\n  - memory: In Bytes or as Mi/Gi (e.g. 128Mi, 16Gi)\n  - gpus: Only used by tasks that execute on the Kubernetes backend\n- resourceManager:\n  - config:\n    - backend: Which backend to use. Valid options are:\n      - local (default option)\n      - kubernetes\n      - lsf\n    - walltime: Maximum execution time of a single task for this component (in minutes). This option is only valid for `kubernetes` and `lsf` backends. The defaults is `60` (one hour).\n  - kubernetes: Options to use when the `kubernetes` backend is selected for this component\n    - image: which image to use\n    - gracePeriod: Kubernetes waits `gracePeriod` seconds between asking a container to terminate and forcing it to terminate. This applies to tasks that use the Kubernetes backend and their execution time exceeds `resourceManager.config.walltime` minutes.\n    - qos: One of \"guaranteed\" (default), \"burstable\", \"besteffort\". See Kubernetes [documentation](https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/) for the definition of Quality Of Service (QoS) classes.\n  - lsf:\n    - queue: Name of queue to submit jobs to.\n    - resourceString: A LSF request string e.g. `\"rusage[ngpus_physical=4.00] select[(v100&&infiniband)]\"`\n- variables: A `key: value` collection of variables; can either override those defined in platform or introduce new ones. In both cases the value specified here is visible to *this* component only. See [FlowIR options/variable inheritance sequence](#flowir-optionsvariable-inheritance-sequence) for details on how scope layering/inheritance functions in FlowIR.\n\n#### Defining components\n\nComponents are placed inside the `components` array:\n\n```yaml\ncomponents:\n- stage: int\n  name: str\n  <component-core>\n  override:\n    <platform name:str>:\n      <component-core>\n```\n\nComponents must have a unique `(stage, name)` tuple. Here's an extract from the `sum-numbers` example:\n\n```yaml\ncomponents:\n# ...\n- stage: 1\n  name: PartialSum\n  command:\n    executable: \"bin/sum.py\"\n    arguments: \"ExtractRow:output\"\n  references: [\"ExtractRow:output\"]\n```\n\n\n\n## DataReference\n\n`DataReference` is the way to define references to data in FlowIR.\n\nComponents define their dependencies to other components in the graph and data external to the graph (e.g. `input`, `data`, and `application-dependencies`) using `DataReference`s.\n[Key-outputs](#key-outputs) also use `DataReference`s.\n\n A `DataReference` can have two forms: an `absolute` and a `relative` representation. The latter is syntax sugar for the former.\n\n#### Absolute representation of DataReference\n\n ```\n stage<Index>.<producerName>:/<fileRef>:<method>\n ```\n\nThe `DataReference` points to either a `component` in the graph or a `directory` in the root of the instance directory.\n\n- `stage<Index>.`: is the stage of the producer. This is only valid for `DataReference`s that point to components. `Index` should be an integer greater than 0.\n- `producerName`: Either the name of a producer `component`, or the name of the `directory` in the root of the instance directory. The directories include all `application-dependencies` and directories that `ST4SD` manages (e.g. `input`, `data`, `conf`, `hooks`, etc).\n- `</fileRef>`: Optional path, relative to the root directory of the `producer`. When omitted defaults to `/`.\n- `method`: One of `ref`, `output`, `copy`, `link`. The `method` determines how ST4SD interprets the `DataReference`.\n   - `ref`: The `DataReference` expands to the absolute path of the referenced file/directory\n   - `output`: The `DataReference` expands to the `contents` of the referenced file.\n      If the reference is to a component with the `fileref` \"/\" then the `DataReference` is rewritten to point to the file containing the most recent `stdout` of the component.\n   - `copy`: The `DataReference` does not expand to anything. If a `component` definition contains such a `DataReference` in its `references` field, then the runtime will copy the referenced path inside the root directory of the component's task right before the execution of the task.\n   - `link`: Similar to `copy` above. The difference is that instead of copying the referenced path, the runtime will create a link to the referenced path.\n\n#### Relative representation of a DataReference\n\nThe `relative` representation of a `DataReference` is just syntax sugar for the `absolute` representation. The `DataReference` can omit the `stage<Index>` part.\n\n- If the relative `DataReference` is in the `references` field of a `component` then the `Index` is the same as the `component.stage` field.\n- If the relative `DataReference` is in a [`key-output`](#key-outputs) definition then the `key-output` should also contain the `stages` field. See [`key-output`](#key-outputs) documentation for more details.\n\n## Environments\n\nThe environment that components run in is defined within the `environments` section of the FlowIR YAML. If you don't define anything in this section ST4SD will create a default environment. \n\nExample:\n\n```yaml\nenvironments:\n  <platform-name>:\n    myDefinedEnvironment:\n      ENV-VAR1: value/for/env-var1\n      ENV-VAR2: value/for/env-var2\n```\n\nA component uses a defined environment by setting `command.environment` to the environment name. For example:\n\n```yaml\ncomponents:\n  - name: myComponent\n    command:\n      executable: app.exe\n      environment: myDefinedEnvironment\n```\n\nYou can set `command.environment` to `None` to ensure ST4SD does not add any environment variables to the task execution. Note, backends ST4SD uses e.g. k8s, lsf, may add env-vars afterwards. \n\nIf `command.environment` is not explicitly set, the `st4sd-runtime` will default to using a built-in, environment called `environment`. This contains the environment from which `elaunch.py` was run.\n\nYou can override the definition of `environment` if you wish, for example:\n\n```yaml\nenvironments:\n  default:\n    environment:\n      ENV-VAR1: sensible/default/for/env-var1\n      ENV-VAR2: sensible/default/for/env-var2\n      ENV-VAR3: sensible/default/for/env-var3\n```\n\n\n\n## Variables\n\nThe `variables` field follows the format below:\n\n```yaml\nvariables:\n  <platform name:str>:\n    Optional(global):\n      <variable name:str>: <value: str, int, bool, float>\n    Optional(stages):\n      <stage index: int>:\n        <variable name:str>: <value: str, int, bool, float>\n```\n\nVariables are grouped under a platform, and can either be global or stage-specific. This example uses the following variables definition:\n\n```yaml\nvariables:\n  default:\n    global:\n      numberOfPoints: 3\n    stages:\n      2:\n        addToSum: 10\n\n  artifactory:\n    stages:\n      2:\n        addToSum: -5\n```\n\n## Using Variables\n\nYou refer to variables in FlowIR with the syntax `%($VARIABLE_NAME)s`.\n\nFlowIR supports using variables to define:\n\n- values of fields\n- values of other variables\n\nFor example:\n\n```yaml\nvariables:\n  default:\n    global:\n      salutation: \"hello\"\n      subject: \"world\"\n      message: \"%(salutation)s %(subject)s\"\n\ncomponents:\n- name: hello-message\n  command:\n    executable: echo\n    arguments: \"%(message)s\"\n```\n\nHere we use the value of the `message` variable in the arguments of the `hello-message` component.\nThe value assigned to the `message` variable itself uses two other variables, `salutation` and `subject`.\n\n<InlineNotification kind=\"info\">\n\nThe first character of the value for a YAML field cannot be `%` so\nremember to enclose fields that contain variables references in quotes.\n\n\n</InlineNotification>\n\n\n### Variables can contain space separated arrays\n\n\nYou can also treat a variable as an array of space separated items.\nHere's you can reference the `<index>`-th entry of a `<variable>`:\n\n`%(<variable>)s[<Index>]`\n\n<InlineNotification kind=\"info\">\n\nThe 1st entry is at index 0.\n\n</InlineNotification>\n\nExamples:\n- `%(names)s[0]`: This resolves to the 1st entry in the `names` array.\n- `%(names)s[%(index)s]`: Indices may be variables too!\n\n```yaml\nvariables:\n  default:\n    global:\n      # All variables are strings in FlowIR\n      names: Ann Bob\n      # Even those that look like a number\n      population: 2\n\ncomponents:\n- name: hello-you\n  command:\n    executable: echo\n    # Here we use the  auto-generated `replica` variable\n    # that st4sd injects to replicating Components\n    arguments: \"hi %(names)s[%(replica)s]\"\n  workflowAttributes:\n    # You can use variables in any field.\n    replicate: \"%(population)s\"\n```\n\n<InlineNotification kind=\"info\">\n\nVariables are all strings in FlowIR. If ST4SD expects a field to have a certain type then it will coerce the value\nthat variable references resolve to into the appropriate type. In the example above `workflowAttributes.replicate`\nexpects an _integer_ value. ST4SD will convert the value of the variable population `population` to\nthe integer value `2`.\n\n</InlineNotification>\n\n\n## Blueprints\n\nST4SD supports defining default options for (a) all components and/or (b) for components that belong in a specific stage, via the `blueprint` top-level field:\n\n```yaml\nblueprint:\n  <platform name:str>:\n    Optional(global):\n      <component options>\n    Optional(stages):\n      <stage index:int>:\n        <component options>\n```\n\nThis example defines the blueprint for 2 platforms. It specifies the default options when using the 2 platforms (setting values for resourceManager, resourceRequest for all components when `artifactory` is the chosen platform) and specializes components in stage 1 when using the `artifactory` platform (increase their memory request)\n\n```yaml\nblueprint:\n  default:\n    global:\n      command:\n        environment: environment\n  artifactory:\n    global:\n      resourceRequest:\n        memory: 100Mi\n      resourceManager:\n        config:\n          backend: kubernetes\n        kubernetes:\n          image: res-drl-hpc-docker-local.artifactory.swg-devops.com/st4sd-runtime-core:latest\n    stages:\n      1:\n        resourceRequest:\n            memory: 150Mi\n```\n\n## Platforms\n\nA platform is a named collection of [blueprints](#blueprints), [variables](#variables), [overrides](#override) and [environments](#environments).\n\nYou define the named platforms using the top-level `platform` array\n\n```yaml\nplatforms:\n   - bigmem\n   - nvidia-gpu\n```\n\nWhen you run a workflow you specify the platform by name. Then the relevant sections of  [blueprints](#blueprints), [variables](#variables), [overrides][#override] and [environments](#environments) will become active. \n\nPlatforms are designed to assist in implementing generic components which are specialized for different purposes when specifying different platforms. This is particularly useful when working with packages that can utilize various kinds of HPC resources (e.g. a cluster fitted with LSF, a kubernetes installation, etc). For example, a component can be configured to utilize a certain amount of GPUs when it targets platform A but exclusively use CPUs on platform B.\n\nIn the sum-numbers example there exist 2 platforms: `default`, and `artifactory`. The `default` platform leads to components executing as vanilla Operating System. Whereas, the `artifactory` platform configures the workflow for execution on kubernetes.\n\n### default platform\n\nThe `default` platform is special: The `st4sd-runtime` fills in missing fields of the `default` blueprint. See, this platform is intended to act as the `base` layer for workflow environments, and component variables/options. When an option/variable/environment is defined within the `default` platform it is automatically inherited by all other platforms (unless they explicitly override said option/variable/environment); read the [FlowIR options/variable inheritance sequence](#flowir-optionsvariable-inheritance-sequence) section for more information on the options/variable layering aspect of ST4SD platforms.\n\nIn this example, the `default` platform defines two variable (a global, and one that is only visible for components in stage 2), the special environment `environment`, and a global blueprint which sets the default value of the `command.environment` options for all components. See [environments](#environments) for more information about environments.\n\n### artifactory platform\n\nThe `artifactory` platform overrides the default value (from `10` to `-5`) for the stage 2 variable `addToSum`, defines default options for all components which instruct the `st4sd-runtime` to utilize the `kubernetes` backend, and overrides the `environment` environment. Moreover, it serves as an example on how to use the layering system of ST4SD to specialize the components which belong in a particular stage. Specifically, the `artifactory` platform configures components belonging in stage 1 to use `150Mi` of memory instead of `100Mi` and `0.1` CPU-units instead of `0.25`.\n\n## FlowIR Scopes\n\nThe `st4sd-runtime` supports nested scopes:\n\n- global (i.e. visible to all components)\n- visible to components within a specific stage\n- visible to just one component\n\nThese scopes are layered in a specific order by the `st4sd-runtime`.\n\n\n## FlowIR options/variable inheritance sequence\n\nThis is the full order of inheritance for component options.\n\n1. Builtin `st4sd-runtime` blueprint\n1. Default `global` blueprint\n1. Default `stage` blueprint\n1. Platform `global` blueprint\n1. Platform `stage` blueprint\n1. Component definition\n1. Resolve interpreter option which may affect command.executable and command.arguments\n\nInheritance for `variables` works in the same spirit (it's effectively the same order of steps but without steps: `1` and `7`).\n\nIn the case of `environments`, the `st4sd-runtime` follows the rules below:\n\n1. If the environment is None (i.e. no environment is selected) then the environment contains the active shell environment.\n1. If the name is the literal string \"none\" then the environment contains {}\n1. Otherwise the `st4sd-runtime` uses the definition for the environment name from the selected platform. If there is no definition in the active platform the `st4sd-runtime` falls back to the  `default` platform.\n1. If an environment defines a `DEFAULTS` key then that key is expected to have the format `VAR1:VAR2:VAR3...`. Other options in the environment could reference the aforementioned vars using the `$VAR` and `${VAR}` notation and these options will be resolved using their matching keys in the default environment. \n   1. Any $VAR and ${VAR} references not matched by `DEFAULTS` keys will be resolved using the active shell(workflow launch environment). \n   1. If a variable is defined in `DEFAULTS` but there is no value for it in the default environment then treat it as if it was never in the `DEFAULTS` option in the first place.\n\n<InlineNotification>\n\n**Tip**: You can use the `ccommand.py` utility to get a list of all FlowIR details for a particular component of a workflow package using the `-f` (i.e. `--flowirReport`) option. Use `--env` to also view the contents of the component environment. Try targeting different platforms via the `-p` argument.\n\n</InlineNotification>\n\n### Default options\n\nThe careful reader will notice that the `default` platform does not contain an option for `resourceManager.config.backend`. How does the `st4sd-runtime` decide which backend to use?\n\nRecall that the `st4sd-runtime` injects default values for the `default.global` blueprint which are then inherited by all components. The default value for `resourceManager.config.backend` is `local` which instructs the `st4sd-runtime` to spawn component tasks as vanilla operating system processes. You can find a detailed list of the ST4SD default values in the ST4SD documentation.\n\n## Key-outputs\n\nKey-Outputs are named [`DataReferences`](#datareference) that point to important paths which the virtual experiment produced.\n\nExample:\n\n```yaml\noutput:\n  OptimisationResults:\n    data-in: stage1.ExtractEnergies/energies.csv:ref\n    description: homo/lumo results\n    type: csv\n```\n\nAbove, `output` is a top-level dictionary whose keys are names of `key-outputs`. Each key points to a dictionary with this schema:\n\n```yaml\ndata-in: \"a DataReference\"\n\n# Optional fields\ndescription: \"A human readable description of the file\"\ntype: \"e.g. csv, pdf, etc - this only used to label key-output\"\nstages:\n- stage0\n- stage1\n```\n\n<InlineNotification kind=\"info\">\nThe DataReference in \"data-in\" can use one of the following reference methods: :ref, :copy, or :output. Here, :copy is just an alias for :ref (i.e paths are not copied). Finally, :output is an alias to out.stdout:ref if the DataReference does not have a /fileRef. Otherwise, :output becomes an alias to /fileRef:ref.\n</InlineNotification>\n\n<InlineNotification kind=\"info\">\nIf \"data-in\" does not contain a \"stage$index.\" prefix then you can list stages to use as the \"stage\" prefix. If you provide multiple stages then later stages will override the path.\n</InlineNotification>\n\n## Interface and Properties\n\nThe `interface` of a virtual experiment (e.g. workflow) defines:\n\n- The specification used to describe `input` systems it processes e.g. SMILEs for small molecules\n- Instructions to extract the `input` systems from input data\n- Instructions to extract the values of `properties` that the virtual experiment computes\n\nYou can find more information about writing an interface [here](/writing-a-virtual-experiment-interface) and a tutorial on how to use an interface [here](/using-a-virtual-experiment-interface)\n","type":"Mdx","contentDigest":"9463b0c08c077c2755122ecbe1827448","owner":"gatsby-plugin-mdx","counter":201},"frontmatter":{"title":"Workflow Specification"},"exports":{},"rawBody":"---\ntitle: Workflow Specification\n---\n\n<!--\n\n  Copyright IBM Inc. All Rights Reserved.\n  SPDX-License-Identifier: Apache-2.0\n\n-->\n\n<PageDescription>\n\nUse this page to learn what FlowIR elements are there and how they work.\n\n</PageDescription>\n\n<AnchorLinks>\n  <AnchorLink>Component</AnchorLink>\n  <AnchorLink>DataReference</AnchorLink>\n  <AnchorLink>Environments</AnchorLink>\n  <AnchorLink>Variables</AnchorLink>\n  <AnchorLink>Blueprints</AnchorLink>\n  <AnchorLink>Platforms</AnchorLink>\n  <AnchorLink>FlowIR Scopes</AnchorLink>\n  <AnchorLink>FlowIR options/variable inheritance sequence</AnchorLink>\n  <AnchorLink>Key-outputs</AnchorLink>\n  <AnchorLink>Interface and Properties</AnchorLink>\n</AnchorLinks>\n\n## Component\n\nThe component element describes a step in the workflow. The definition for a component is (some fields omitted):\n\n```yaml\nstage: integer greater or equal to 0 (optional - defaults to 0)\nname: the name of the component (must be unique in the same stage)\ncommand:\n  executable: str\n  arguments: str\n  environment: (null, str)\nreferences:\n- <reference:str>\nworkflowAttributes:\n  aggregate: bool\n  replicate: (int, null, str containing %(variable-reference)s or array access)\nresourceRequest:\n  numberProcesses: (int, str containing %(variable-reference)s or array access)\n  numberThreads: (int, str containing %(variable-reference)s or array access)\n  ranksPerNode: (int, str containing %(variable-reference)s or array access)\n  threadsPerCore: (int, str containing %(variable-reference)s or array access)\n  memory: (int (size in bytes), str containing %(variable-reference)s or array access or Mib/Kib bytes )\nresourceManager:\n  config:\n    backend: (name of backend e.g \"local\", \"kubernetes\", \"lsf\", etc:str)\n  kubernetes:\n    image: str\n    image-pull-secret: (null, str)\n    namespace: (null, str)\n    host: (null, str)\nvariables:\n  s<variable name:str>: <value: str, int, bool, float>\n```\n\n### Override\n\nComponents have an `override` key that allows overriding their definition based on the active platform. The definition of the override field is:\n\n```yaml\noverride:\n  <platform name:str>:\n    <component-field> #Any top-level field (with the sub-keys to be overriden) except name, stage  command and reference\n```\n\nThe main reason to do this is change `variables` ,`workflowAttributes` `resourceManager` or `resourceRequest`, based on e.g. GPU or CPU deployment (see [platform][#platforms]).\n\nOnly the key/values specified are changed or added. Existing key/values that aren't specified remain with their base values. For example:\n\n```yaml\n...\nresourceRequest:\n  numberThreads: 16\n  threadsPerCore: 1\n\tmemory: 100 MBi\noverride:\n   bigmem:\n     resourceRequest:\n       memory: 1GBi\n```\n\nIn this case on platform `bigmem` this component would still ask for 16 cores but with an increased memory request.  \n\n### Description of basic FlowIR component fields\n\n- stage: integer greater or equal to 0 (optional - defaults to 0)\n- name: the name of the component (must be unique in the same stage)\n- command:\n  - executable: path to executable. It can be absolute, relative to the instance directory by prefixing the path with `bin/` or `<application>/`. It can also be just the name of a binary. If the path is not absolute the `st4sd-runtime` will look for the executable in the folders specified under `$PATH`.\n  - arguments: arguments to binary\n  - environment: Name of the `environment` to use. The definition will be searched in the top level `environments` field of FlowIR.\n- references: Each string in this list is a string representation of a [DataReference](#datareference) to either a reference to a file, a folder, or a component. References to components and files produced by a component (i.e. under the working directory of a component) indicate a data dependency which the `st4sd-runtime` respects when scheduling the tasks for components. There are several `reference methods`, but these are the most commonly used:\n  - `:output`: the `st4sd-runtime` will replace `<component name>:output` references with the `stdout` output of the referenced component\n  - `:ref`: the `st4sd-runtime` will replace `<component name or file>:ref` references with the absolute path to the component or file on the filesystem.\n  - `:copy`: the `st4sd-runtime` will copy the file referenced by this DataReference into the working directory of the component which includes this reference. This DataReference method cannot be part of the `command.arguments` field.\n- workflowAttributes:\n  - replicate: If set to a positive number `N` the `st4sd-runtime` will replicate this component and its downstream tree `N` times (see `aggregate` below before you use this option).\n  - aggregate: If this option is set to `True` and the component belongs in the downstream sub-tree of a `replicate` component the `st4sd-runtime` will stop replicating just before the `aggregate` component. Each reference of the `aggregate` component to the `replicate` component will be expanded to `N` references (one for each upstream replicated component).\n- resourceRequest: provides hints to the backend about the resource requirements of this component tasks\n  - numberProcesses\n  - numberThreads\n  - ranksPerNode\n  - threadsPerCore\n  - memory: In Bytes or as Mi/Gi (e.g. 128Mi, 16Gi)\n  - gpus: Only used by tasks that execute on the Kubernetes backend\n- resourceManager:\n  - config:\n    - backend: Which backend to use. Valid options are:\n      - local (default option)\n      - kubernetes\n      - lsf\n    - walltime: Maximum execution time of a single task for this component (in minutes). This option is only valid for `kubernetes` and `lsf` backends. The defaults is `60` (one hour).\n  - kubernetes: Options to use when the `kubernetes` backend is selected for this component\n    - image: which image to use\n    - gracePeriod: Kubernetes waits `gracePeriod` seconds between asking a container to terminate and forcing it to terminate. This applies to tasks that use the Kubernetes backend and their execution time exceeds `resourceManager.config.walltime` minutes.\n    - qos: One of \"guaranteed\" (default), \"burstable\", \"besteffort\". See Kubernetes [documentation](https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/) for the definition of Quality Of Service (QoS) classes.\n  - lsf:\n    - queue: Name of queue to submit jobs to.\n    - resourceString: A LSF request string e.g. `\"rusage[ngpus_physical=4.00] select[(v100&&infiniband)]\"`\n- variables: A `key: value` collection of variables; can either override those defined in platform or introduce new ones. In both cases the value specified here is visible to *this* component only. See [FlowIR options/variable inheritance sequence](#flowir-optionsvariable-inheritance-sequence) for details on how scope layering/inheritance functions in FlowIR.\n\n#### Defining components\n\nComponents are placed inside the `components` array:\n\n```yaml\ncomponents:\n- stage: int\n  name: str\n  <component-core>\n  override:\n    <platform name:str>:\n      <component-core>\n```\n\nComponents must have a unique `(stage, name)` tuple. Here's an extract from the `sum-numbers` example:\n\n```yaml\ncomponents:\n# ...\n- stage: 1\n  name: PartialSum\n  command:\n    executable: \"bin/sum.py\"\n    arguments: \"ExtractRow:output\"\n  references: [\"ExtractRow:output\"]\n```\n\n\n\n## DataReference\n\n`DataReference` is the way to define references to data in FlowIR.\n\nComponents define their dependencies to other components in the graph and data external to the graph (e.g. `input`, `data`, and `application-dependencies`) using `DataReference`s.\n[Key-outputs](#key-outputs) also use `DataReference`s.\n\n A `DataReference` can have two forms: an `absolute` and a `relative` representation. The latter is syntax sugar for the former.\n\n#### Absolute representation of DataReference\n\n ```\n stage<Index>.<producerName>:/<fileRef>:<method>\n ```\n\nThe `DataReference` points to either a `component` in the graph or a `directory` in the root of the instance directory.\n\n- `stage<Index>.`: is the stage of the producer. This is only valid for `DataReference`s that point to components. `Index` should be an integer greater than 0.\n- `producerName`: Either the name of a producer `component`, or the name of the `directory` in the root of the instance directory. The directories include all `application-dependencies` and directories that `ST4SD` manages (e.g. `input`, `data`, `conf`, `hooks`, etc).\n- `</fileRef>`: Optional path, relative to the root directory of the `producer`. When omitted defaults to `/`.\n- `method`: One of `ref`, `output`, `copy`, `link`. The `method` determines how ST4SD interprets the `DataReference`.\n   - `ref`: The `DataReference` expands to the absolute path of the referenced file/directory\n   - `output`: The `DataReference` expands to the `contents` of the referenced file.\n      If the reference is to a component with the `fileref` \"/\" then the `DataReference` is rewritten to point to the file containing the most recent `stdout` of the component.\n   - `copy`: The `DataReference` does not expand to anything. If a `component` definition contains such a `DataReference` in its `references` field, then the runtime will copy the referenced path inside the root directory of the component's task right before the execution of the task.\n   - `link`: Similar to `copy` above. The difference is that instead of copying the referenced path, the runtime will create a link to the referenced path.\n\n#### Relative representation of a DataReference\n\nThe `relative` representation of a `DataReference` is just syntax sugar for the `absolute` representation. The `DataReference` can omit the `stage<Index>` part.\n\n- If the relative `DataReference` is in the `references` field of a `component` then the `Index` is the same as the `component.stage` field.\n- If the relative `DataReference` is in a [`key-output`](#key-outputs) definition then the `key-output` should also contain the `stages` field. See [`key-output`](#key-outputs) documentation for more details.\n\n## Environments\n\nThe environment that components run in is defined within the `environments` section of the FlowIR YAML. If you don't define anything in this section ST4SD will create a default environment. \n\nExample:\n\n```yaml\nenvironments:\n  <platform-name>:\n    myDefinedEnvironment:\n      ENV-VAR1: value/for/env-var1\n      ENV-VAR2: value/for/env-var2\n```\n\nA component uses a defined environment by setting `command.environment` to the environment name. For example:\n\n```yaml\ncomponents:\n  - name: myComponent\n    command:\n      executable: app.exe\n      environment: myDefinedEnvironment\n```\n\nYou can set `command.environment` to `None` to ensure ST4SD does not add any environment variables to the task execution. Note, backends ST4SD uses e.g. k8s, lsf, may add env-vars afterwards. \n\nIf `command.environment` is not explicitly set, the `st4sd-runtime` will default to using a built-in, environment called `environment`. This contains the environment from which `elaunch.py` was run.\n\nYou can override the definition of `environment` if you wish, for example:\n\n```yaml\nenvironments:\n  default:\n    environment:\n      ENV-VAR1: sensible/default/for/env-var1\n      ENV-VAR2: sensible/default/for/env-var2\n      ENV-VAR3: sensible/default/for/env-var3\n```\n\n\n\n## Variables\n\nThe `variables` field follows the format below:\n\n```yaml\nvariables:\n  <platform name:str>:\n    Optional(global):\n      <variable name:str>: <value: str, int, bool, float>\n    Optional(stages):\n      <stage index: int>:\n        <variable name:str>: <value: str, int, bool, float>\n```\n\nVariables are grouped under a platform, and can either be global or stage-specific. This example uses the following variables definition:\n\n```yaml\nvariables:\n  default:\n    global:\n      numberOfPoints: 3\n    stages:\n      2:\n        addToSum: 10\n\n  artifactory:\n    stages:\n      2:\n        addToSum: -5\n```\n\n## Using Variables\n\nYou refer to variables in FlowIR with the syntax `%($VARIABLE_NAME)s`.\n\nFlowIR supports using variables to define:\n\n- values of fields\n- values of other variables\n\nFor example:\n\n```yaml\nvariables:\n  default:\n    global:\n      salutation: \"hello\"\n      subject: \"world\"\n      message: \"%(salutation)s %(subject)s\"\n\ncomponents:\n- name: hello-message\n  command:\n    executable: echo\n    arguments: \"%(message)s\"\n```\n\nHere we use the value of the `message` variable in the arguments of the `hello-message` component.\nThe value assigned to the `message` variable itself uses two other variables, `salutation` and `subject`.\n\n<InlineNotification kind=\"info\">\n\nThe first character of the value for a YAML field cannot be `%` so\nremember to enclose fields that contain variables references in quotes.\n\n\n</InlineNotification>\n\n\n### Variables can contain space separated arrays\n\n\nYou can also treat a variable as an array of space separated items.\nHere's you can reference the `<index>`-th entry of a `<variable>`:\n\n`%(<variable>)s[<Index>]`\n\n<InlineNotification kind=\"info\">\n\nThe 1st entry is at index 0.\n\n</InlineNotification>\n\nExamples:\n- `%(names)s[0]`: This resolves to the 1st entry in the `names` array.\n- `%(names)s[%(index)s]`: Indices may be variables too!\n\n```yaml\nvariables:\n  default:\n    global:\n      # All variables are strings in FlowIR\n      names: Ann Bob\n      # Even those that look like a number\n      population: 2\n\ncomponents:\n- name: hello-you\n  command:\n    executable: echo\n    # Here we use the  auto-generated `replica` variable\n    # that st4sd injects to replicating Components\n    arguments: \"hi %(names)s[%(replica)s]\"\n  workflowAttributes:\n    # You can use variables in any field.\n    replicate: \"%(population)s\"\n```\n\n<InlineNotification kind=\"info\">\n\nVariables are all strings in FlowIR. If ST4SD expects a field to have a certain type then it will coerce the value\nthat variable references resolve to into the appropriate type. In the example above `workflowAttributes.replicate`\nexpects an _integer_ value. ST4SD will convert the value of the variable population `population` to\nthe integer value `2`.\n\n</InlineNotification>\n\n\n## Blueprints\n\nST4SD supports defining default options for (a) all components and/or (b) for components that belong in a specific stage, via the `blueprint` top-level field:\n\n```yaml\nblueprint:\n  <platform name:str>:\n    Optional(global):\n      <component options>\n    Optional(stages):\n      <stage index:int>:\n        <component options>\n```\n\nThis example defines the blueprint for 2 platforms. It specifies the default options when using the 2 platforms (setting values for resourceManager, resourceRequest for all components when `artifactory` is the chosen platform) and specializes components in stage 1 when using the `artifactory` platform (increase their memory request)\n\n```yaml\nblueprint:\n  default:\n    global:\n      command:\n        environment: environment\n  artifactory:\n    global:\n      resourceRequest:\n        memory: 100Mi\n      resourceManager:\n        config:\n          backend: kubernetes\n        kubernetes:\n          image: res-drl-hpc-docker-local.artifactory.swg-devops.com/st4sd-runtime-core:latest\n    stages:\n      1:\n        resourceRequest:\n            memory: 150Mi\n```\n\n## Platforms\n\nA platform is a named collection of [blueprints](#blueprints), [variables](#variables), [overrides](#override) and [environments](#environments).\n\nYou define the named platforms using the top-level `platform` array\n\n```yaml\nplatforms:\n   - bigmem\n   - nvidia-gpu\n```\n\nWhen you run a workflow you specify the platform by name. Then the relevant sections of  [blueprints](#blueprints), [variables](#variables), [overrides][#override] and [environments](#environments) will become active. \n\nPlatforms are designed to assist in implementing generic components which are specialized for different purposes when specifying different platforms. This is particularly useful when working with packages that can utilize various kinds of HPC resources (e.g. a cluster fitted with LSF, a kubernetes installation, etc). For example, a component can be configured to utilize a certain amount of GPUs when it targets platform A but exclusively use CPUs on platform B.\n\nIn the sum-numbers example there exist 2 platforms: `default`, and `artifactory`. The `default` platform leads to components executing as vanilla Operating System. Whereas, the `artifactory` platform configures the workflow for execution on kubernetes.\n\n### default platform\n\nThe `default` platform is special: The `st4sd-runtime` fills in missing fields of the `default` blueprint. See, this platform is intended to act as the `base` layer for workflow environments, and component variables/options. When an option/variable/environment is defined within the `default` platform it is automatically inherited by all other platforms (unless they explicitly override said option/variable/environment); read the [FlowIR options/variable inheritance sequence](#flowir-optionsvariable-inheritance-sequence) section for more information on the options/variable layering aspect of ST4SD platforms.\n\nIn this example, the `default` platform defines two variable (a global, and one that is only visible for components in stage 2), the special environment `environment`, and a global blueprint which sets the default value of the `command.environment` options for all components. See [environments](#environments) for more information about environments.\n\n### artifactory platform\n\nThe `artifactory` platform overrides the default value (from `10` to `-5`) for the stage 2 variable `addToSum`, defines default options for all components which instruct the `st4sd-runtime` to utilize the `kubernetes` backend, and overrides the `environment` environment. Moreover, it serves as an example on how to use the layering system of ST4SD to specialize the components which belong in a particular stage. Specifically, the `artifactory` platform configures components belonging in stage 1 to use `150Mi` of memory instead of `100Mi` and `0.1` CPU-units instead of `0.25`.\n\n## FlowIR Scopes\n\nThe `st4sd-runtime` supports nested scopes:\n\n- global (i.e. visible to all components)\n- visible to components within a specific stage\n- visible to just one component\n\nThese scopes are layered in a specific order by the `st4sd-runtime`.\n\n\n## FlowIR options/variable inheritance sequence\n\nThis is the full order of inheritance for component options.\n\n1. Builtin `st4sd-runtime` blueprint\n1. Default `global` blueprint\n1. Default `stage` blueprint\n1. Platform `global` blueprint\n1. Platform `stage` blueprint\n1. Component definition\n1. Resolve interpreter option which may affect command.executable and command.arguments\n\nInheritance for `variables` works in the same spirit (it's effectively the same order of steps but without steps: `1` and `7`).\n\nIn the case of `environments`, the `st4sd-runtime` follows the rules below:\n\n1. If the environment is None (i.e. no environment is selected) then the environment contains the active shell environment.\n1. If the name is the literal string \"none\" then the environment contains {}\n1. Otherwise the `st4sd-runtime` uses the definition for the environment name from the selected platform. If there is no definition in the active platform the `st4sd-runtime` falls back to the  `default` platform.\n1. If an environment defines a `DEFAULTS` key then that key is expected to have the format `VAR1:VAR2:VAR3...`. Other options in the environment could reference the aforementioned vars using the `$VAR` and `${VAR}` notation and these options will be resolved using their matching keys in the default environment. \n   1. Any $VAR and ${VAR} references not matched by `DEFAULTS` keys will be resolved using the active shell(workflow launch environment). \n   1. If a variable is defined in `DEFAULTS` but there is no value for it in the default environment then treat it as if it was never in the `DEFAULTS` option in the first place.\n\n<InlineNotification>\n\n**Tip**: You can use the `ccommand.py` utility to get a list of all FlowIR details for a particular component of a workflow package using the `-f` (i.e. `--flowirReport`) option. Use `--env` to also view the contents of the component environment. Try targeting different platforms via the `-p` argument.\n\n</InlineNotification>\n\n### Default options\n\nThe careful reader will notice that the `default` platform does not contain an option for `resourceManager.config.backend`. How does the `st4sd-runtime` decide which backend to use?\n\nRecall that the `st4sd-runtime` injects default values for the `default.global` blueprint which are then inherited by all components. The default value for `resourceManager.config.backend` is `local` which instructs the `st4sd-runtime` to spawn component tasks as vanilla operating system processes. You can find a detailed list of the ST4SD default values in the ST4SD documentation.\n\n## Key-outputs\n\nKey-Outputs are named [`DataReferences`](#datareference) that point to important paths which the virtual experiment produced.\n\nExample:\n\n```yaml\noutput:\n  OptimisationResults:\n    data-in: stage1.ExtractEnergies/energies.csv:ref\n    description: homo/lumo results\n    type: csv\n```\n\nAbove, `output` is a top-level dictionary whose keys are names of `key-outputs`. Each key points to a dictionary with this schema:\n\n```yaml\ndata-in: \"a DataReference\"\n\n# Optional fields\ndescription: \"A human readable description of the file\"\ntype: \"e.g. csv, pdf, etc - this only used to label key-output\"\nstages:\n- stage0\n- stage1\n```\n\n<InlineNotification kind=\"info\">\nThe DataReference in \"data-in\" can use one of the following reference methods: :ref, :copy, or :output. Here, :copy is just an alias for :ref (i.e paths are not copied). Finally, :output is an alias to out.stdout:ref if the DataReference does not have a /fileRef. Otherwise, :output becomes an alias to /fileRef:ref.\n</InlineNotification>\n\n<InlineNotification kind=\"info\">\nIf \"data-in\" does not contain a \"stage$index.\" prefix then you can list stages to use as the \"stage\" prefix. If you provide multiple stages then later stages will override the path.\n</InlineNotification>\n\n## Interface and Properties\n\nThe `interface` of a virtual experiment (e.g. workflow) defines:\n\n- The specification used to describe `input` systems it processes e.g. SMILEs for small molecules\n- Instructions to extract the `input` systems from input data\n- Instructions to extract the values of `properties` that the virtual experiment computes\n\nYou can find more information about writing an interface [here](/writing-a-virtual-experiment-interface) and a tutorial on how to use an interface [here](/using-a-virtual-experiment-interface)\n","fileAbsolutePath":"/Users/vassilis/projects/st4sd/public/overview/src/pages/workflow-specification.mdx"}}},"staticQueryHashes":["1364590287","137577622","2102389209","2456312558","2746626797","3018647132","3037994772","768070550"]}