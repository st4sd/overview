"use strict";(self.webpackChunkst4sd_overview=self.webpackChunkst4sd_overview||[]).push([[216],{2138:function(e,t,n){n.r(t),n.d(t,{_frontmatter:function(){return p},default:function(){return y}});var a=n(45),i=(n(6540),n(5680)),o=n(8027),r=n(786);const s=["components"],p={},l=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.yg)("div",t)},u=l("PageDescription"),m=l("AnchorLinks"),c=l("AnchorLink"),g=l("ExpressiveList"),d={_frontmatter:p},h=o.A;function y(e){let{components:t}=e,n=(0,a.A)(e,s);return(0,i.yg)(h,Object.assign({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.yg)(u,{mdxType:"PageDescription"},(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"elaunch.py")," command line tool executes and monitors virtual experiments. You can use it to run experiments on your laptop or on a High Performance Computing Cluster. When you submit a virtual experiment via ST4SD API it is executed by ",(0,i.yg)("inlineCode",{parentName:"p"},"elaunch.py"),".")),(0,i.yg)(m,{mdxType:"AnchorLinks"},(0,i.yg)(c,{mdxType:"AnchorLink"},"Running experiments with elaunch.py"),(0,i.yg)(c,{mdxType:"AnchorLink"},"Checking if your experiment worked"),(0,i.yg)(c,{mdxType:"AnchorLink"},"What is the output of my experiment ?"),(0,i.yg)(c,{mdxType:"AnchorLink"},"What is the status of my experiment ?"),(0,i.yg)(c,{mdxType:"AnchorLink"},"Troubleshooting"),(0,i.yg)(c,{mdxType:"AnchorLink"},"How do I select an execution platform ?"),(0,i.yg)(c,{mdxType:"AnchorLink"},"How to restart an experiment ?")),(0,i.yg)("h2",null,"Install elaunch.py"),(0,i.yg)("p",null,"If you haven’t already, install the ",(0,i.yg)("inlineCode",{parentName:"p"},"st4sd-runtime-core")," python package:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'pip install "st4sd-runtime-core[develop]"\n')),(0,i.yg)("h2",null,"Running experiments with elaunch.py"),(0,i.yg)("p",null,"With elaunch.py you can run experiments - sets of files describing computational workflows - given their path: simply run ",(0,i.yg)("inlineCode",{parentName:"p"},"elaunch.py <path to experiment>"),"."),(0,i.yg)("p",null,"For example, you can run the toy workflow ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/st4sd/nanopore-geometry-experiment"},(0,i.yg)("inlineCode",{parentName:"a"},"nanopore-geometry-experiment"))," like so:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},': # Get the directory that provides input to the next command\ngit clone https://github.com/st4sd/nanopore-geometry-experiment.git\n\ncd nanopore-geometry-experiment\n\n: # Run elaunch.py specifying certain files in the directory created above\nelaunch.py --nostamp -l 40 --input docker-example/cif_files.dat \\\n      --applicationDependencySource="nanopore-database=cif:copy" \\\n      nanopore-geometry-experiment.package\n')),(0,i.yg)("p",null,"The experiment should take about 5 minutes to complete. The ",(0,i.yg)("inlineCode",{parentName:"p"},"-l 40")," option keeps the log printouts to the bare minimum. When the experiment completes expect to see something similar to the following text on your terminal:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"completed-on=2024-03-15 14:39:29.909105\ncost=0\ncreated-on=2024-03-15 14:38:04.402969\ncurrent-stage=stage3\nexit-status=Success\nexperiment-state=finished\nstage-progress=1.0\nstage-state=finished\nstages=['stage0', 'stage1', 'stage2', 'stage3']\ntotal-progress=1.0\nupdated=2024-03-15 14:39:33.804727\nupdated-on=2024-03-15 14:39:33.804727\n")),(0,i.yg)("p",null,"Running an experiment creates a directory which contains the outputs. For example, the code above creates the directory ",(0,i.yg)("inlineCode",{parentName:"p"},"nanopore-geometry-experiment.instance"),". See Section ",(0,i.yg)("a",{parentName:"p",href:"#what-is-the-output-of-my-experiment"},"What is the output of my experiment?")," for more information."),(0,i.yg)("h3",null,"Experiment project types"),(0,i.yg)("p",null,"Experiments can be packaged in two different ways. One way is the ",(0,i.yg)("inlineCode",{parentName:"p"},"standalone")," project which is the example we show above. This type of experiments only support a single virtual experiment and are best suited for workflows with many artifacts or resources that are actively changing (i.e., they have multiple commits)."),(0,i.yg)("p",null,"Standalone projects contain:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"a ",(0,i.yg)("inlineCode",{parentName:"li"},"conf")," directory with the experiment definition files"),(0,i.yg)("li",{parentName:"ul"},"(optional) a ",(0,i.yg)("inlineCode",{parentName:"li"},"data")," directory with data files that the workflow steps can reference and the users may override at execution time"),(0,i.yg)("li",{parentName:"ul"},"(optional) additional custom directories that the workflow developers include for the workflow steps to reference")),(0,i.yg)("p",null,"Another type is the ",(0,i.yg)("inlineCode",{parentName:"p"},"standard")," project. These are flexible, allowing for multiple virtual experiment definitions to be bundled together and share files, like scripts and restart hooks. They consist of"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"a YAML file that contains the experiment definition"),(0,i.yg)("li",{parentName:"ul"},"(optional) manifest YAML file listing the directories that the virtual experiment needs and where they will be accessible from when it is running.")),(0,i.yg)("h3",null,"Providing input files"),(0,i.yg)("p",null,"Experiments typically require inputs to function properly. To view them, you can use the command ",(0,i.yg)("inlineCode",{parentName:"p"},"einputs.py <path to experiment>"),". Refer to the documentation of the experiment you’re trying to run to find out more about the necessary inputs. "),(0,i.yg)("p",null,"To pass inputs to your experiment, you can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"-i ${path to input file}")," option in ",(0,i.yg)("inlineCode",{parentName:"p"},"elaunch.py"),". In the above example we provide the input file ",(0,i.yg)("inlineCode",{parentName:"p"},"cif_files.dat")," which is located in the directory ",(0,i.yg)("inlineCode",{parentName:"p"},"docker-example"),"."),(0,i.yg)("p",null,"If you want to use an input file whose name ",(0,i.yg)("strong",{parentName:"p"},"is not the same")," as the one the experiment expects, you must map them explicitly with ",(0,i.yg)("inlineCode",{parentName:"p"},"--input $local_path:$input_name"),". For example, to use the contents of the file ",(0,i.yg)("inlineCode",{parentName:"p"},"/tmp/my-file.dat")," as the input file ",(0,i.yg)("inlineCode",{parentName:"p"},"cif_files.dat")," above you would specify ",(0,i.yg)("inlineCode",{parentName:"p"},"--input /tmp/my-file.dat:cif_files.dat"),"."),(0,i.yg)("h3",null,"Setting configuration options"),(0,i.yg)("p",null,"Experiments may also come with configuration options that you can optionally override. We call these options ",(0,i.yg)("inlineCode",{parentName:"p"},"variables")," and you can use ",(0,i.yg)("inlineCode",{parentName:"p"},"einputs.py")," to get the list of variables (and their default) values for an experiment."),(0,i.yg)("p",null,"For example, here is the relevant section from the output of ",(0,i.yg)("inlineCode",{parentName:"p"},"einputs.py nanopore-geometry-experiment.package"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-yaml"},"optional:\n  variables:\n    global:\n      numberOfNanopores: 1\n      probeRadius_A: 1.4\n      zeo_memory: 2Gi\n")),(0,i.yg)("p",null,"Typically the experiment documentation explains what these variables control. To configure their values, put together a ",(0,i.yg)("inlineCode",{parentName:"p"},"variables")," file using the format:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-yaml"},"global:\n  parameterName: value\n")),(0,i.yg)("p",null,"Use this variables file with your experiment by specifying the ",(0,i.yg)("inlineCode",{parentName:"p"},"elaunch.py")," argument ",(0,i.yg)("inlineCode",{parentName:"p"},"-a ${path to variables file}"),". Take care when formatting the ",(0,i.yg)("inlineCode",{parentName:"p"},"variables.yaml")," file, it should follow the indentation and syntax of YAML files."),(0,i.yg)("h2",null,"Checking if your experiment worked"),(0,i.yg)("p",null,"If the experiment works ",(0,i.yg)("inlineCode",{parentName:"p"},"elaunch.py")," prints ",(0,i.yg)("inlineCode",{parentName:"p"},"exit-status=Success")," before it terminates and then exits with return code 0. You can find more information about the status of your experiment under the file ",(0,i.yg)("inlineCode",{parentName:"p"},"${package_name}-${timestamp}.instance/output/status.txt"),". For example, here’s a ",(0,i.yg)("inlineCode",{parentName:"p"},"status.txt")," for a successful run of an experiment:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"completed-on=2024-03-15 14:39:29.909105\ncost=0\ncreated-on=2024-03-15 14:38:04.402969\ncurrent-stage=stage3\nexit-status=Success\nexperiment-state=finished\nstage-progress=1.0\nstage-state=finished\nstages=['stage0', 'stage1', 'stage2', 'stage3']\ntotal-progress=1.0\nupdated=2024-03-15 14:39:33.804727\nupdated-on=2024-03-15 14:39:33.804727\n")),(0,i.yg)("p",null,"If the experiment fails you will see the line ",(0,i.yg)("inlineCode",{parentName:"p"},"exit-status=Failed")," in the logs of ",(0,i.yg)("inlineCode",{parentName:"p"},"elaunch.py")," and it will exit with a return code other than ",(0,i.yg)("inlineCode",{parentName:"p"},"0"),". If the experiment failed after the instance directory was created you will see this information in the ",(0,i.yg)("inlineCode",{parentName:"p"},"output/status.txt")," file too. Common reasons for failures are invalid syntax, missing input files, or requesting a compute resource that is not available. For more information and dealing with these errors see our ",(0,i.yg)("a",{parentName:"p",href:"#troubleshooting"},"Troubleshooting")," section."),(0,i.yg)("h2",null,"What is the output of my experiment ?"),(0,i.yg)("p",null,"All outputs of the experiment are placed in a directory called ",(0,i.yg)("inlineCode",{parentName:"p"},"${package-name}-${timestamp}.instance")," which is created in the directory you were in when you ran ",(0,i.yg)("inlineCode",{parentName:"p"},"elaunch.py"),". The structure of this directory is:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"output"),": contains the runtime logs and files describing the outputs and status of your experiment"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"stages"),": contains one directory per stage of your experiment. Each stage directory contains one directory per component in that stage of your experiment."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"inputs"),": contains the input files you provided, including any variable files"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"data"),": (optional) contains files that the workflow definition bundles and the workflow steps can reference. Users may optionally override those files when they launch an experiment"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"conf"),": contains the experiment definition")),(0,i.yg)("p",null,"The key directories are ",(0,i.yg)("inlineCode",{parentName:"p"},"output")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"stages"),"."),(0,i.yg)("h3",null,"The output directory"),(0,i.yg)("p",null,"It contains the following files:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"experiment.log: the logs of the ",(0,i.yg)("inlineCode",{parentName:"li"},"elaunch.py")," process"),(0,i.yg)("li",{parentName:"ul"},"status.txt: the final status of the experiment (see the status printout above for an example)"),(0,i.yg)("li",{parentName:"ul"},"status_details.json: Similar to above but easier to consume programmatically"),(0,i.yg)("li",{parentName:"ul"},"output.txt: contains metadata about key files that your experiments produce i.e. key outputs. This file gets updated when when the key named files that one of your tasks produced. It contains information such as their path relative to the root of the instance directory, modification time, etc."),(0,i.yg)("li",{parentName:"ul"},"output.json: Similar to above but easier to consume programmatically"),(0,i.yg)("li",{parentName:"ul"},"properties.csv: (optional) If your experiment defines its ",(0,i.yg)("a",{parentName:"li",href:"/overview/using-a-virtual-experiment-interface"},"interface"),", then this file contains the measured properties of your experiment,"),(0,i.yg)("li",{parentName:"ul"},"input-ids.json: (optional) If your experiment defines its ",(0,i.yg)("a",{parentName:"li",href:"/overview/using-a-virtual-experiment-interface"},"interface"),", then this file contains an array with the input ids that your experiment processed"),(0,i.yg)("li",{parentName:"ul"},"additional_input_data.json: (optional) If your experiment defines its interface, then this file contains dictionary whose keys are input ids and values are additional input data (e.g. absolute paths) associated with the corresponding input id")),(0,i.yg)("h3",null,"The stages directory"),(0,i.yg)("p",null,"A virtual experiment is a computational workflow that executes tasks. Task outputs are organized under the ",(0,i.yg)("inlineCode",{parentName:"p"},"stages")," directory like so: ",(0,i.yg)("inlineCode",{parentName:"p"},"stages/stage{$index}/${task-name}"),". To find out the tasks that are in your experiment read the  experiment definition or look at the file structure of the ",(0,i.yg)("inlineCode",{parentName:"p"},"stages")," directory."),(0,i.yg)("h3",null,"Understanding an experiment’s execution requirements"),(0,i.yg)("p",null,"The experiment documentation should explain what is required to execute it. For example, an experiment contains a set of tasks and elaunch.py submits those tasks to the backends that the tasks select. This means that if the machine on which you run elaunch.py does not support the backend that a task selects then elaunch.py cannot run that task."),(0,i.yg)("h3",null,"How to run elaunch with LSF ?"),(0,i.yg)("p",null,"Some experiments can launch tasks on using the batch scheduler LSF (IBM Spectrum). If an experiment supports execution on LSF it should say so in its documentation and explain how to launch using it."),(0,i.yg)("p",null,"To launch an experiment that supports LSF you need to also install the official ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/IBMSpectrumComputing/lsf-python-api"},(0,i.yg)("inlineCode",{parentName:"a"},"lsf-python-api"))," python module:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},". /path/to/profile.lsf\ngit clone https://github.com/IBMSpectrumComputing/lsf-python-api.git\ncd lsf-python-api\npython3 setup.py build\npython3 setup.py install\n")),(0,i.yg)("p",null,"Check the homepage of ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/IBMSpectrumComputing/lsf-python-api"},(0,i.yg)("inlineCode",{parentName:"a"},"lsf-python-api"))," for more information."),(0,i.yg)("h3",null,"How to override experiment configuration data files"),(0,i.yg)("p",null,"Experiments may optionally bundle data files which you may override. The experiment documentation should explain what these files are and what your options are for overriding. Additionally ",(0,i.yg)("inlineCode",{parentName:"p"},"einputs.py")," displays the names of the data files that an experiment references."),(0,i.yg)("h3",null,"Store outputs to S3"),(0,i.yg)("p",null,"Experiments may optionally upload their ",(0,i.yg)("a",{parentName:"p",href:"/overview/tutorial#key-outputs"},(0,i.yg)("inlineCode",{parentName:"a"},"key-outputs"))," to S3 after termination. You can instruct ",(0,i.yg)("inlineCode",{parentName:"p"},"elaunch.py")," to upload these files to S3 using the ",(0,i.yg)("inlineCode",{parentName:"p"},"--s3StoreToURI")," parameter. When using this parameter, you must also specify exactly one of the parameters ",(0,i.yg)("inlineCode",{parentName:"p"},"--s3AuthWithEnvVars")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"--s3AuthBearer64"),"."),(0,i.yg)("h3",null,"Example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},'export bucket="a-bucket"\nexport path_in_bucket="optional/path"\n\nexport S3_ACCESS_KEY_ID="s3 access key id"\nexport S3_SECRET_ACCESS_KEY="s3 secret access key"\nexport S3_END_POINT="s3 end point"\n\nelaunch.py --s3StoreToURI s3://${bucket}/${path_in_bucket} \\\n  --s3AuthWithEnvVars path/to/experiment\n')),(0,i.yg)("p",null,"When ",(0,i.yg)("inlineCode",{parentName:"p"},"--s3StoreToURI")," is set, after the experiment terminates, ",(0,i.yg)("inlineCode",{parentName:"p"},"elaunch.py")," will start uploading the ",(0,i.yg)("inlineCode",{parentName:"p"},"key-outputs")," to the S3 bucket you provided under the specified ",(0,i.yg)("inlineCode",{parentName:"p"},"${path_in_bucket}"),". ",(0,i.yg)("inlineCode",{parentName:"p"},"elaunch.py")," replaces occurrences of the ",(0,i.yg)("inlineCode",{parentName:"p"},"%(instanceDir)s")," literal in ",(0,i.yg)("inlineCode",{parentName:"p"},"--s3StoreToURI")," with the name of the experiment instance. For example, you can use this to store the ",(0,i.yg)("inlineCode",{parentName:"p"},"key-outputs")," of multiple workflow instances in the same bucket."),(0,i.yg)("p",null,"Alternatively, you can base64-encode the JSON representation of the dictionary ",(0,i.yg)("inlineCode",{parentName:"p"},'{"S3_ACCESS_KEY_ID": "val", "S3_SECRET_ACCESS_KEY": "val", "S3_END_POINT": "val"}')," and use the ",(0,i.yg)("inlineCode",{parentName:"p"},"--s3AuthBearer64")," parameter instead:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},'export bucket="a-bucket"\nexport path_in_bucket="optional/path"\nexport json="{\\"S3_ACCESS_KEY_ID\\": \\"val\\", \\"S3_SECRET_ACCESS_KEY\\": \\"val\\", \\"S3_END_POINT\\": \\"val\\"}"\nexport s3_auth=`echo "${json}" | base64`\n\nelaunch.py --s3StoreToURI s3://${bucket}/${path_in_bucket} \\\n  --s3AuthBearer64 path/to/experiment\n')),(0,i.yg)("h2",null,"What is the status of my experiment ?"),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"elaunch.py")," script will periodically store information about the status of your experiment instance under its ",(0,i.yg)("inlineCode",{parentName:"p"},"$instanceDir")," directory. You can use ",(0,i.yg)("inlineCode",{parentName:"p"},"einspect.py")," to see the current status of tasks in your experiment instance."),(0,i.yg)("p",null,"Here is an example output of running ",(0,i.yg)("inlineCode",{parentName:"p"},"einspect.py")," after a ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/st4sd/sum-numbers"},(0,i.yg)("inlineCode",{parentName:"a"},"sum-numbers"))," experiment terminates."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"cd sum-numbers-2024-03-15T143804.402969.instance\neinspect.py -f all\n\n\nWARNING   MainThread                     root                          : <module>             2024-03-15 14:39:50,782: No instance given - checking if inside one\n\n========== STAGE 0 ==========\n\nComponents using engine-type: engine\nreference, state, backend, isWaitingOnOutput, engineExitReason, lastTaskRunTime, lastTaskRunState\nstage0.GenerateInput, finished, local, True, Success, 0:00:00.241827, finished\n\n========== STAGE 1 ==========\n\nComponents using engine-type: engine\nreference, state, backend, isWaitingOnOutput, engineExitReason, lastTaskRunTime, lastTaskRunState\nstage1.ExtractRow0, finished, local, True, Success, 0:01:00.197737, finished\nstage1.ExtractRow1, finished, local, True, Success, 0:01:00.227356, finished\nstage1.ExtractRow2, finished, local, True, Success, 0:01:00.208578, finished\nstage1.PartialSum0, finished, local, True, Success, 0:00:00.368524, finished\nstage1.PartialSum1, finished, local, True, Success, 0:00:00.385971, finished\nstage1.PartialSum2, finished, local, True, Success, 0:00:00.410082, finished\n\n========== STAGE 2 ==========\n\nComponents using engine-type: engine\nreference, state, backend, isWaitingOnOutput, engineExitReason, lastTaskRunTime, lastTaskRunState\nstage2.Sum, finished, local, True, Success, 0:00:00.061634, finished\n\n========== STAGE 3 ==========\n\nComponents using engine-type: engine\nreference, state, backend, isWaitingOnOutput, engineExitReason, lastTaskRunTime, lastTaskRunState\nstage3.Cat, finished, local, True, Success, 0:00:00.013691, finished\n")),(0,i.yg)("p",null,"You may also see a summary of your status in the ",(0,i.yg)("inlineCode",{parentName:"p"},"$instanceDir/output/status.txt")," file:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"completed-on=2024-03-15 14:39:29.909105\ncost=0\ncreated-on=2024-03-15 14:38:04.402969\ncurrent-stage=stage3\nexit-status=Success\nexperiment-state=finished\nstage-progress=1.0\nstage-state=finished\nstages=['stage0', 'stage1', 'stage2', 'stage3']\ntotal-progress=1.0\nupdated=2024-03-15 14:39:33.804727\nupdated-on=2024-03-15 14:39:33.804727\n")),(0,i.yg)("p",null,"The current status of your experiment is the value of ",(0,i.yg)("inlineCode",{parentName:"p"},"exit-status"),"."),(0,i.yg)("h2",null,"Troubleshooting"),(0,i.yg)("p",null,"If the ",(0,i.yg)("inlineCode",{parentName:"p"},"exit-status")," of your experiment instance is ",(0,i.yg)("inlineCode",{parentName:"p"},"Failed")," then this means that at least one of your components was unable to terminate successfully. You can find the name of the component that caused the experiment to fail in the ",(0,i.yg)("inlineCode",{parentName:"p"},"status")," file and printout."),(0,i.yg)("p",null,"Here is an example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"completed-on=2024-05-23 09:44:03.757679\ncost=0\ncreated-on=2024-05-23 09:42:19.223491\ncurrent-stage=stage1\nerror-description=Stage 1 failed. Reason:\\\\\\\\n3 jobs failed unexpectedly.\\\\\\\\nJob: stage1.PartialSum0. Returncode 1. Reason KnownIssue\\\\\\\\nJob: stage1.PartialSum2. Returncode 1. Reason KnownIssue\\\\\\\\nJob: stage1.PartialSum1. Returncode 1. Reason KnownIssue\\\\\\\\n\nexit-status=Failed\nexperiment-state=finished\nstage-progress=0.5\nstage-state=failed\nstages=['stage0', 'stage1', 'stage2', 'stage3']\ntotal-progress=0.875\nupdated=2024-05-23 09:44:08.793316\nupdated-on=2024-05-23 09:44:08.793316\n")),(0,i.yg)("p",null,"The error reports that multiple components failed: ",(0,i.yg)("inlineCode",{parentName:"p"},"stage1.PartialSum0"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"stage1.PartialSum1"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"stage1.PartialSum2"),"."),(0,i.yg)("p",null,"You may also get a full view of the state of the experiment by using the ",(0,i.yg)("inlineCode",{parentName:"p"},"einspect.py -f all")," tool."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"========== STAGE 0 ==========\n\nComponents using engine-type: engine\nreference, state, backend, isWaitingOnOutput, engineExitReason, lastTaskRunTime, lastTaskRunState\nstage0.GenerateInput, finished, local, True, Success, 0:00:00.358677, finished\n\n========== STAGE 1 ==========\n\nComponents using engine-type: engine\nreference, state, backend, isWaitingOnOutput, engineExitReason, lastTaskRunTime, lastTaskRunState\nstage1.ExtractRow0, finished, local, True, Success, 0:01:00.246955, finished\nstage1.ExtractRow1, finished, local, True, Success, 0:01:00.209115, finished\nstage1.ExtractRow2, finished, local, True, Success, 0:01:00.226946, finished\nstage1.PartialSum0, failed, local, True, KnownIssue, 0:00:00.323739, failed\nstage1.PartialSum1, failed, local, True, KnownIssue, 0:00:00.336899, failed\nstage1.PartialSum2, failed, local, True, KnownIssue, 0:00:00.360914, failed\n\n========== STAGE 2 ==========\n\nComponents using engine-type: engine\nreference, state, backend, isWaitingOnOutput, engineExitReason, lastTaskRunTime, lastTaskRunState\nstage2.Sum, component_shutdown, local, False, Killed, N/A, N/A\n\n========== STAGE 3 ==========\n\nComponents using engine-type: engine\nreference, state, backend, isWaitingOnOutput, engineExitReason, lastTaskRunTime, lastTaskRunState\nstage3.Cat, finished, local, True, Success, 0:00:00.011466, finished\n")),(0,i.yg)("p",null,"After you spot a ",(0,i.yg)("inlineCode",{parentName:"p"},"Failed")," component, try looking at the files it produced, including its stdout and stderr (for some backends both streams get fed into stdout). Recall that you can find these files under ",(0,i.yg)("inlineCode",{parentName:"p"},"$INSTANCE_DIR/stages/stage<stage index>/<component name>/"),". Look for the ",(0,i.yg)("inlineCode",{parentName:"p"},"out.stdout")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"out.stderr")," files."),(0,i.yg)("p",null,"Sometimes, a component fails because one of its predecessors (direct, or indirect) produced unexpected output. To find the predecessors of a component, look at the ",(0,i.yg)("inlineCode",{parentName:"p"},"$INSTANCE_DIR/conf/flowir_instance.yaml"),", locate the component you are investigating and then follow its predecessors by looking at the ",(0,i.yg)("inlineCode",{parentName:"p"},"references")," of the component. You can then investigate the output files and stdout/stderr of those components to see if you can spot why the downstream component failed."),(0,i.yg)("h2",null,"How do I select an execution platform ?"),(0,i.yg)("p",null,"Often, workflows have support for multiple execution environments such as Cloud (e.g. Kubernetes/OpenShift), HPC, or even personal devices like laptops.\nST4SD uses the concept of execution platform to help workflow developers define how their workflows should execute under different execution environments.\nPlatforms are designed to assist in implementing generic components which are specialized for different purposes when specifying different platforms. This is particularly useful when working with packages that can utilize various kinds of HPC resources (e.g. a cluster fitted with LSF, a kubernetes installation, etc). For example, a component can be configured to utilize a certain amount of GPUs when it targets platform A but exclusively use CPUs on platform B. You can find more information about platforms ",(0,i.yg)("a",{parentName:"p",href:"/overview/workflow-specification#platforms"},"in our docs"),"."),(0,i.yg)("p",null,"Use ",(0,i.yg)("inlineCode",{parentName:"p"},"einputs.py <path to package>")," to find a list of the platforms that an experiment supports. The experiment documentation should explain the requirements for executing the experiment with any of the platforms. To select a platform use the ",(0,i.yg)("inlineCode",{parentName:"p"},"--platform")," commandline argument of ",(0,i.yg)("inlineCode",{parentName:"p"},"elaunch.py"),". If you don’t provide the commandline parameter ",(0,i.yg)("inlineCode",{parentName:"p"},"--platform")," then ",(0,i.yg)("inlineCode",{parentName:"p"},"elaunch.py")," will select the platform called ",(0,i.yg)("inlineCode",{parentName:"p"},"default")," which is the default platform of experiments."),(0,i.yg)("h2",null,"How to restart an experiment ?"),(0,i.yg)("p",null,"Sometimes it’s useful to restart a previously completed experiment instance instead of starting a brand new instance. For example, you can modify a script that a component in the instance used and then restart all components starting from a specific stage index and onwards."),(0,i.yg)("p",null,"To restart an existing instance from a given stage index use ",(0,i.yg)("inlineCode",{parentName:"p"},"elaunch.py --restart <stageindex> ... path/to/dir.instance"),". All components from stage ",(0,i.yg)("inlineCode",{parentName:"p"},"<stageindex>")," and onwards will be restarted. This means that ",(0,i.yg)("inlineCode",{parentName:"p"},"elaunch.py")," will run the logic of their ",(0,i.yg)("inlineCode",{parentName:"p"},"restart hook")," and may re-run a component depending on the output of the restart method. Use the ",(0,i.yg)("inlineCode",{parentName:"p"},"--noRestartHooks")," option with ",(0,i.yg)("inlineCode",{parentName:"p"},"--restart")," to skip the restart hook logic and re-run the components. Find out more information about ",(0,i.yg)("inlineCode",{parentName:"p"},"restart")," hooks in ",(0,i.yg)("a",{parentName:"p",href:"/overview/restart"},"our docs"),"."),(0,i.yg)("h2",null,"Learn more"),(0,i.yg)("div",{className:"expressive-content-list-group"},(0,i.yg)(g,{title:"Exploring the Registry UI",background:"true",pictogram:(0,i.yg)(r.LCQ,{mdxType:"CarbonForIbmDotcom"}),mdxType:"ExpressiveList"},(0,i.yg)("p",null,"Learn about all the features of\n",(0,i.yg)("a",{parentName:"p",href:"/overview/using-the-virtual-experiments-registry-ui"},"our web interface")," for browsing and\nexamining virtual experiments packages and runs. You can visit the\n",(0,i.yg)("a",{parentName:"p",href:"https://registry.st4sd.res.ibm.com/"},"ST4SD Global Registry")," for a first look.")),(0,i.yg)(g,{title:"No Code, No Fuss creation of Experiments",background:"true",pictogram:(0,i.yg)(r.PxR,{mdxType:"ArtTools_01"}),mdxType:"ExpressiveList"},(0,i.yg)("p",null,"Use\n",(0,i.yg)("a",{parentName:"p",href:"/overview/build-experiments-registry-ui"},"an interactive Build Canvas and a Graph Library"),"\nto create and modify experiments straight from your browser."))))}y.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-direct-run-mdx-3607bb34012111d4d198.js.map